<!DOCTYPE html>
<html lang="zh-CN-diy">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Qinshihuang&#39;s Blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Qinshihuang&#39;s Blog">
<meta property="og:locale">
<meta property="article:author" content="Qinshihuang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN-diy'
  };
</script>

  <title>Qinshihuang's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Qinshihuang's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">秦屎皇的小窝</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>目录</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN-diy">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/05/22/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Qinshihuang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qinshihuang's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/22/%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">树上问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-05-22 21:30:37 / 修改时间：22:32:54" itemprop="dateCreated datePublished" datetime="2024-05-22T21:30:37+08:00">2024-05-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h1><p>图论定义：无向无环连通图。</p>
<blockquote>
<p>等价定义：无相连通图，$n$ 个点和 $n-1$ 条边；$n$ 个点和 $n-1$ 条边的图，任意两个点之间有且仅有一条简单路径可以到达……</p>
</blockquote>
<p>更具体的来说，树是一张无向图 $\mathcal T=(V,E)$，其中 $|E|=|V|-1$ 且任意两个点都联通。同时定义有根树和无根树的概念：有根树在 $V$ 中有一个特殊元素 $root$ 作为整棵树的根，而无根树没有。对于有根树，定义点 $u$ 的深度 $dep_u=\operatorname{dis}(u,root)$。</p>
<h1 id="直径、半径等问题"><a href="#直径、半径等问题" class="headerlink" title="直径、半径等问题"></a>直径、半径等问题</h1><p>直径的定义：树上长度最大的路径长度。</p>
<p>半径的定义：随意定节点为根时整棵树的深度最小值。</p>
<p>解决直径半径等问题的主要方法是树形 dp。</p>
<h2 id="直径"><a href="#直径" class="headerlink" title="直径"></a>直径</h2><h3 id="树形-dp-求解"><a href="#树形-dp-求解" class="headerlink" title="树形 dp 求解"></a>树形 dp 求解</h3><p>首先我们钦定 $1$ 为根。</p>
<p>我们考虑设 $f_u$ 表示从点 $u$ 向下走的最大深度。显然有</p>
<script type="math/tex; mode=display">
f_u=\max\{f_v+w(u,v)\}</script><p>我们再设 $g_u$ 为 $u$ 子树中直径长度。显然路径可以分成两种：穿过 $u$ 的和不穿过 $u$ 的。我们考虑求出所有 $u$ 儿子 $v$ 的 $f_v$ 第一第二大 $\mathrm{first},\mathrm{second}$，那么答案可以记作</p>
<script type="math/tex; mode=display">
g_u=\max(\max\{g_v\},f_\mathrm{first}+w(u,\mathrm{first})+f_\mathrm{second}+w(u,\mathrm{second}))</script><h3 id="两次-dfs-求解"><a href="#两次-dfs-求解" class="headerlink" title="两次 dfs 求解"></a>两次 dfs 求解</h3><blockquote>
<p>引理：对于一棵树上的点 $u$，距离 $u$ 最远的点一定是树上某条直径的端点之一。</p>
<p><strong>证明</strong> 考虑反证法。设距离 $u$ 最远的点是 $v$。考虑一条直径 $(l,r)$，不妨设 $l$ 距离 $u$ 比 $r$ 更远。那么</p>
<script type="math/tex; mode=display">
\operatorname{dis}(u,v)>\operatorname{dis}(u,l)</script><p>因此</p>
<script type="math/tex; mode=display">
\begin{aligned}
\operatorname{dis}(v,r)&=\operatorname{dis}(u,v)+\operatorname{dis}(u,r)\\
&>\operatorname{dis}(u,l)+\operatorname{dis}(u,r)=\operatorname{dis}(l,r)
\end{aligned}</script><p>这与 $(l,r)$ 是直径矛盾。因此引理成立。</p>
</blockquote>
<p>因此我们不妨钦定 $1$ 为根来对整棵树求出深度。因为深度就是点到根的距离，因此深度最大的点一定是直径端点之一。记这个点为 $u$，以它为根进行第二次 dfs 来求出深度，记深度最大的点为 $v$，那么 $(u,v)$ 一定是一条直径。（注意到直径不一定唯一）</p>
<h2 id="半径"><a href="#半径" class="headerlink" title="半径"></a>半径</h2><p>考虑换根 dp 求解。在上面 dp 求直径的 $f_u$ 基础上设 $h_u$ 为 $u$ 向上走的最长距离（可以去到兄弟）。</p>
<p>那么显然有 dp 方程</p>
<script type="math/tex; mode=display">
h_u=w(u,\mathrm{father})+\max(h_{\mathrm{father}},\max_{v\in\mathrm{brother}\ u}\{f_v+\operatorname{dis}(\mathrm{father},v)\})</script><p>那么以 $u$ 为根的时候树的深度就是 $f_u+h_u$，那么树的半径就是</p>
<script type="math/tex; mode=display">
\min\{f_u+h_u\}</script><h2 id="例题：SDOI2024-第二轮省级-D6T3-粉兔的154"><a href="#例题：SDOI2024-第二轮省级-D6T3-粉兔的154" class="headerlink" title="例题：SDOI2024 第二轮省级 D6T3 粉兔的154"></a>例题：SDOI2024 第二轮省级 D6T3 粉兔的154</h2><blockquote>
<p>这是一道构造题。</p>
<p>给定一个数组 $a_1,a_2,\dots,a_n$，其中 $a_i=-1$ 或 $a_i\in[1,n]$，你需要构造一棵有 $n$ 个点的无根树，每条边权都为 $1$，满足对于点 $u$：</p>
<ul>
<li>若 $a_u=-1$，则存在至少两个树上的点 $v_1,v_2$ 使得 $\operatorname{dis}(u,v_1)=\operatorname{dis}(u,v_2)&gt;\operatorname{dis}(u,v)$，其中 $v\neq v_1$ 且 $v\neq v_2$。</li>
<li>否则一定满足 $\operatorname{dis}(u,a_u)&gt;\operatorname{dis}(u,v)$，其中 $v\neq a_u$。</li>
</ul>
<p>给出构造或者判定不可能。</p>
<p>$n\le10^6$。记 $S$ 为 $a_i$ 组成的集合，则分 subtask：</p>
<p>$n\le10$，$|S|=1\sim 4$，无限制。</p>
</blockquote>
<p>子任务很神奇，先看子任务。</p>
<h3 id="n-le-10"><a href="#n-le-10" class="headerlink" title="$n\le 10$"></a>$n\le 10$</h3><p>写个爆搜枚举父亲即可，时间复杂度 $O(n\times n!)$。</p>
<p>为啥要写暴力。因为暴力能完美规避大量 corner。</p>
<h3 id="S-的限制"><a href="#S-的限制" class="headerlink" title="$|S|$ 的限制"></a>$|S|$ 的限制</h3><p>以下默认 $n&gt;10$。</p>
<p>当 $a_i$ 全部相同的时候，显然 $a_i=-1$ 有解，否则无解。$a_i=-1$ 的时候菊花图满足条件。</p>
<p>$|S|=2$ 时候，我们先不考虑 corner case。当 $-1\in S$ 的时候，通过玩我们可以找到这样一个符合条件的结构：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/sf3ljvt3.png" style="zoom:67%;" /></p>
<p>其中 $tar$ 是唯一非 $-1$ 的 $a_i$ 的值，$a_x=a_y=a_{u_1}=a_{u_2}=\dots=a_{u_p}=-1$，$a_{v_1}=a_{v_2}=\dots=a_{v_q}=tar$。</p>
<p>考虑这种情况下什么不行。容易发现 $q\le 2$ 不可以。</p>
<p>在继续讨论之前，我们先证明一个引理：$S$ 中有 $3$ 个非 $-1$ 元素时一定无解。</p>
<blockquote>
<p><strong>证明</strong> 不妨设 $S$ 中三个非 $-1$ 元素为 $v_1,v_2,v_3$。考虑到 $(v_1,v_2)$ 以及 $(v_1,v_3)$ 都是直径，考察一个 $a_u=v_2$ 的 $u$，显然 $\operatorname{dis}(u,v_2)=\operatorname{dis}(u,v_3)$（无论大于还是小于都会破坏假设），因此 $a_u$ 应当等于 $-1$。矛盾。</p>
</blockquote>
<p>因此我们排除了很多情况。因此我们只剩下两种情况：$S=\{v_1,v_2\}$ 和 $S=\{v_1,v_2,-1\}$。</p>
<h3 id="最后的讨论"><a href="#最后的讨论" class="headerlink" title="最后的讨论"></a>最后的讨论</h3><p>这两种情况是本质相同的：$(v_1,v_2)$ 是树上的唯一直径。</p>
<p>考虑将 $a_u=v_1$ 的点挂在 $v_2$ 一侧，相反的挂在另一侧，$a_u=-1$ 的挂在中间，则最后会形成</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/b8pcjcyr.png" style="zoom: 67%;" /></p>
<p>特殊情况就是（$s_l\le 2$ 或 $s_r\le 2$）且 $|s_l-s_r|\neq0$ 时无解。</p>
<p><strong>小心 vector 爆炸导致 RE。</strong></p>
<h3 id="反过头来"><a href="#反过头来" class="headerlink" title="反过头来"></a>反过头来</h3><p>大家可以仔细想想如果不打暴力会怎么样。</p>
<ul>
<li>$n=1$ 时需要特判若 $a_1\neq-1$ 无解否则有解。</li>
<li>$n=2,3$ 时树结构确定，需要特判。</li>
<li>……</li>
</ul>
<p>非常恶心。</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>小粉兔有了另一段坚毅无私的黑历史。</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/vgt0b586.png" style="zoom:50%;" /></p>
<h1 id="虚树"><a href="#虚树" class="headerlink" title="虚树"></a>虚树</h1><p>见 <a target="_blank" rel="noopener" href="https://tmcqsh.github.io/2024/05/09/%E8%99%9A%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">虚树学习笔记</a>。</p>
<h1 id="LCA"><a href="#LCA" class="headerlink" title="LCA"></a>LCA</h1><p>定义啥的不说了。</p>
<h2 id="例题：CF519E-A-and-B-and-Lecture-Rooms"><a href="#例题：CF519E-A-and-B-and-Lecture-Rooms" class="headerlink" title="例题：CF519E A and B and Lecture Rooms"></a>例题：CF519E A and B and Lecture Rooms</h2><blockquote>
<p>给定一个 $n$ 个点的树，边权为 $1$，你需要回答 $q$ 次询问，每次询问给定 $u,v$，你需要统计满足条件的点 $p$ 的数量使得 $\operatorname{dis}(u,p)=\operatorname{dis}(v,p)$。</p>
<p>$n,q\le10^5$。</p>
</blockquote>
<p>不妨钦定 $1$ 为根，我们需要找到 $(u,v)$ 路径上的中点，接在那个点上的所有点都满足条件。</p>
<p>怎么找点？首先求出 $\operatorname{dis}(u,v)$，再求出一半的长度。不妨令 $dep_u&gt;dep_v$，那么从 $u$ 向上跳即可找到中点 $mid$。最后求出挂在上面的点数量就可以了（其实就是减掉旁边的分支）。注意特判 $u=v$。</p>
<p>时间复杂度 $O((n+q)\log n)$。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN-diy">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/05/10/%E8%87%AA%E7%84%B6%E6%95%B0%E6%B1%82%E5%92%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Qinshihuang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qinshihuang's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/10/%E8%87%AA%E7%84%B6%E6%95%B0%E6%B1%82%E5%92%8C/" class="post-title-link" itemprop="url">自然数求和</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-05-10 22:49:44 / 修改时间：22:50:09" itemprop="dateCreated datePublished" datetime="2024-05-10T22:49:44+08:00">2024-05-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="小事"><a href="#小事" class="headerlink" title="小事"></a>小事</h1><blockquote>
<p>什么？</p>
<script type="math/tex; mode=display">
1+2+3+\dots=-\dfrac{1}{12}</script></blockquote>
<h2 id="简单理解"><a href="#简单理解" class="headerlink" title="简单理解"></a>简单理解</h2><p>什么乱七八糟的。</p>
<p>$1$ 是正数，$2$ 是正数，$3$ 是正数，……加起来能是负的？</p>
<p>$1$ 是整数，$2$ 是整数，……加起来能是分数？xswl</p>
<h2 id="上一层次"><a href="#上一层次" class="headerlink" title="上一层次"></a>上一层次</h2><p>其实有点道理对吧，毕竟什么</p>
<script type="math/tex; mode=display">
1-1+1-1+1-1+\dots=\dfrac{1}{2}</script><blockquote>
<p>证明：首先这个可以解释成 $\dfrac{1}{2}$。</p>
<p>其次我们要解释它不能写成啥 $1-(1-1)-(1-1)$ 或者啥 $(1-1)+(1-1)$。</p>
<p>为啥不能加括号？发散级数是不能随意加括号的！因为它不能任意的改变运算顺序。</p>
<p>级数 $(1-1)+(1-1)+(1-1)$ 是一个<strong>收敛</strong>级数，它是可以任意计算的，因为它最终会收敛到一个确定的极限值。</p>
<p>而原来这个东西不能收敛到一个确定的值，因此我们不能随意计算。</p>
</blockquote>
<p>这种鬼东西都能被搞出来，也不能保证这个东西一定是错的对吧。</p>
<p>我们不妨设 $A=1-1+1-1+\dots=\dfrac{1}{2}$。现在我们考虑计算</p>
<script type="math/tex; mode=display">
B=1-2+3-4+5-6+\dots</script><p>考虑</p>
<script type="math/tex; mode=display">
\begin{aligned}
B&=1-2+3-4+5-6+\dots\\
B&=\qquad\!\!1-2+3-4+5-\dots\\
B+B&=1-1+1-1+1-1+\dots=A=\dfrac{1}{2}\\
B&=\dfrac{1}{4}
\end{aligned}</script><p>最后考虑我们的答案，即 $C=1+2+3+4+5+\dots$。</p>
<script type="math/tex; mode=display">
\begin{aligned}
C&=1+2+3+4+\dots\\
-B&=-1+2-3+4-\dots\\
C-B&=4+8+12+16+\dots=4C\\
C&=-\dfrac{1}{12}
\end{aligned}</script><p><del>震惊.jpg</del></p>
<h2 id="拓展视野"><a href="#拓展视野" class="headerlink" title="拓展视野"></a>拓展视野</h2><p>不仅这东西能推出来，甚至在实际的物理学上还有意义！这又是怎么一回事呢？</p>
<p>这就要提到一个叫做卡西米尔效应的问题。<del>可能学过物竞的同学知道</del></p>
<h2 id="回过去看"><a href="#回过去看" class="headerlink" title="回过去看"></a>回过去看</h2><p>什么乱七八糟的。</p>
<p>我们可以引入一个关于<strong>级数收敛</strong>的事情，就是说：</p>
<script type="math/tex; mode=display">
1-1+1-1+1-1+\dots</script><p>的证明过程里对<strong>发散级数</strong>求了收敛值。这怎么能对呢？</p>
<p>同样，最后那个 $C$ 的值也肯定是错的，小学生都知道那个级数发散凭啥能对。</p>
<h2 id="拓展视野-1"><a href="#拓展视野-1" class="headerlink" title="拓展视野"></a>拓展视野</h2><p>我在昨天晚上看到了两个说明 $1-1+1-1+\dots=\dfrac{1}{2}$ 的证明。<del>事实上这个值还是有一些意义的</del></p>
<h3 id="1-切萨罗法求发散级数和"><a href="#1-切萨罗法求发散级数和" class="headerlink" title="1.切萨罗法求发散级数和"></a>1.切萨罗法求发散级数和</h3><p>这算是对发散级数的一个补充吧。</p>
<p>我们不妨定义 $a_0=1,a_1=-1,\dots,a_n=(-1)^n$。</p>
<p>再定义 $s_0=a_0,s_1=a_0+a_1,\dots,s_n=a_0+a_1+\dots+a_n$。</p>
<p>再定义 $\sigma_0=s_0,\sigma_1=\dfrac{s_0+s_1}{2},\dots,\sigma_n=\dfrac{s_0+s_1+\dots+s_n}{n+1}$。</p>
<p>而切萨罗法认为，如果 $n\to\infty$ 时，$\sigma_n$ 极限存在，就将 $\sigma_n$ 的极限称作切萨罗和。</p>
<p>而原数列的切萨罗和就是 $\dfrac{1}{2}$。</p>
<h3 id="2-母函数求法"><a href="#2-母函数求法" class="headerlink" title="2.母函数求法"></a>2.母函数求法</h3><blockquote>
<p>什么是母函数？</p>
<p>通俗的来说，对于数列 $\left<a_0,a_1,a_2,\dots\right>$，可以<strong>生成</strong>一个形式幂级数函数 $A(z)$：</p>
<script type="math/tex; mode=display">
A(z)=\sum_{k=0}^\infty a_kz^k</script></blockquote>
<p>我们考虑将原数列的母函数搞出来：</p>
<script type="math/tex; mode=display">
F(z)=\sum_{k=0}^\infty(-1)^kz^k=\sum_{k=0}^\infty(-z)^k</script><p>可以得到公式</p>
<script type="math/tex; mode=display">
\begin{aligned}
(-z)F(z)&=\sum_{k=1}^\infty (-z)^k\\
(-z)F(z)+1&=\sum_{k=0}^\infty(-z)^k=F(z)\\
F(z)&=\dfrac{1}{1+z}
\end{aligned}</script><p>直接将 $z=1$ 代入得到 $F(1)=\dfrac{1}{2}$。</p>
<h2 id="那为啥自然数的和就不行？"><a href="#那为啥自然数的和就不行？" class="headerlink" title="那为啥自然数的和就不行？"></a>那为啥自然数的和就不行？</h2><p>我们试着用母函数做一做 $B,C$。</p>
<h4 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a>小知识</h4><script type="math/tex; mode=display">
B(z)=\dfrac{1}{(1+z)^2}</script><script type="math/tex; mode=display">
C(z)=\dfrac{1}{(1-z)^2}</script><p>还是一样，我们将 $z=1$ 代入，得到……</p>
<script type="math/tex; mode=display">
B=\dfrac{1}{4},C=\dfrac{1}{0}?</script><p>寄！</p>
<hr>
<p>为什么 $A,B$ 利用母函数可以得到一个值而 $C$ 却没有定义。</p>
<p>XD XD XD 我也没找到啊！！！！！！！！！</p>
<h2 id="拓展视野-2"><a href="#拓展视野-2" class="headerlink" title="拓展视野"></a>拓展视野</h2><p>呃其实还是有意义的。</p>
<p>一个著名的函数 $\zeta(z)$，黎曼函数是这样定义的：</p>
<script type="math/tex; mode=display">
\zeta(z)=\sum_{n=1}^\infty\dfrac{1}{n^z}\quad(\Re(z)>1)</script><p>诶呀不管怎么着好像是将它进行解析沿拓之后就发现 $\zeta(-1)=-\dfrac{1}{12}$ 了，也没法再清楚了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>简单来说，这个问题是错的。</p>
<p>稍微深层次一点，就能发现这个问题不仅是对的而且还有非常实际的物理意义。</p>
<p>再看深一点，你会发现这个问题似乎还是一个没有很良定义的问题。</p>
<p>最后，到了高等数学的范畴，你又能为这个问题找到一个合理的解释，并且将它应用在实际、完善数学的体系。</p>
<p>总而言之，这个问题，有人说它洞察数学的奥妙，有人说它荒谬至极，物理学家赞叹它的不可思议，数学家们却为它煞费苦心。</p>
<script type="math/tex; mode=display">
\sum_{k=1}^\infty k\overset{\underset{?}{}}{=}-\dfrac{1}{12}</script><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><p>Bilibili《全体自然数之和等于-1/12？真相远没有那么简单！》by 漫士沉思录&amp;乐正垂星 <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1si4y1p75k/">Link</a></p>
</li>
<li><p>BiliBili《【官方双语】巴塞尔问题：著名公式背后的惊人几何学》by 3Blue1Brown <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/av20400157/">Link</a></p>
</li>
<li><p>百度百科 拉马努金求和 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%8B%89%E9%A9%AC%E5%8A%AA%E9%87%91%E6%B1%82%E5%92%8C">Link</a></p>
</li>
<li><p>Wolframalpha $\zeta(z)$ <a target="_blank" rel="noopener" href="https://www.wolframalpha.com/input?i=Zeta%28z%29">Link</a></p>
</li>
<li><p>百家号《洞察素数的秘密，黎曼猜想与zeta函数》by 遇见数学 <a target="_blank" rel="noopener" href="https://baijiahao.baidu.com/s?id=1680158228524259841&amp;wfr=spider&amp;for=pc">Link</a></p>
</li>
<li><p>哦，还有<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/article/1gxob6zc">这篇文章</a>，没有它我写不出来这篇文章。</p>
</li>
</ul>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>谢谢大家！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN-diy">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/05/09/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Qinshihuang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qinshihuang's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/09/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/" class="post-title-link" itemprop="url">线性代数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-05-09 21:07:30 / 修改时间：21:41:47" itemprop="dateCreated datePublished" datetime="2024-05-09T21:07:30+08:00">2024-05-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h1><p>Uh-oh.</p>
<blockquote>
<p>也就是说，只要多写写公式你的水平自然会提升。——离散小波变换°</p>
</blockquote>
<h2 id="矩阵和线性方程组"><a href="#矩阵和线性方程组" class="headerlink" title="矩阵和线性方程组"></a>矩阵和线性方程组</h2><p>矩阵是什么。嘴巴嘴巴嘴巴</p>
<p>一个线性方程组可以被描述成 $A\boldsymbol x=\boldsymbol b$ 的形式。</p>
<p>可以利用高斯约旦消元法解，时间复杂度是 $O(n^3)$。</p>
<h2 id="线性空间"><a href="#线性空间" class="headerlink" title="线性空间"></a>线性空间</h2><p>定义线性空间 $V$ 是域 $F$ 上的一个子空间，元素 $\alpha$ 和 $\beta$ 满足：</p>
<ul>
<li>$\alpha+\beta\in V$，有 $e$，$\mathrm{inv}$，交换律，结合律。</li>
<li>乘法：<ul>
<li>$1\cdot \alpha=\alpha$。</li>
<li>$c_1\cdot c_2\alpha=(c_1c_2)\alpha,c(\alpha+\beta)=c\alpha+c\beta,(c_1+c_2)\alpha=c_1\alpha+c_2\alpha$</li>
<li>为什么没写交换律。因为可能没有交换律。</li>
</ul>
</li>
</ul>
<p>线性组合：若存在一组 $c_1,c_2,\dots,c_n$ 满足 $\beta=\sum\limits_{i=1}^nc_i\alpha_i$，则称 $\beta$ 是 $\alpha_i$ 的线性组合。</p>
<p>线性不相关：一组元素 $\alpha_1,\alpha_2,\dots,\alpha_n$ 每个元素都不能表示成其他元素的线性组合。或者另一个定义是方程 $\boldsymbol c\boldsymbol {\alpha}=\boldsymbol 0$ 的唯一解是 $\boldsymbol c=\boldsymbol 0$。</p>
<p>基：张成 $V$ 的一组线性不相关向量 $(\alpha_1,\alpha_2,\dots,\alpha_n)$。并且记 $\dim(V)=n$。</p>
<blockquote>
<p>“张成” $V$ 的定义：要求 $\forall\boldsymbol\beta\in V$，都有一组 $\boldsymbol c=(c_1,c_2,\dots,c_n)$ 使得 $\boldsymbol c\boldsymbol {\alpha}=\boldsymbol \beta$。</p>
</blockquote>
<h2 id="线性变换"><a href="#线性变换" class="headerlink" title="线性变换"></a>线性变换</h2><h3 id="标准定义"><a href="#标准定义" class="headerlink" title="标准定义"></a>标准定义</h3><p>称一个函数 $T:V\rightarrow W$ 为 $V$ 到 $W$ 的<strong>线性变换</strong>当且仅当这东西有线性性。</p>
<blockquote>
<p>即，$c\cdot T(\boldsymbol\alpha)+\boldsymbol \beta=T(c\boldsymbol\alpha+\boldsymbol\beta)$。</p>
</blockquote>
<p>事实上这个映射可以写成矩阵的形式，就是说 $n$ 维空间到 $m$ 维空间就乘上一个 $n\times m$ 的矩阵。</p>
<p>设 $\mathcal B_1=(\boldsymbol\alpha_1,\boldsymbol\alpha_2,\dots,\boldsymbol\alpha_n)$ 为 $V$ 的一组基，$\mathcal B_2=(\boldsymbol\beta_1,\boldsymbol\beta_2,\dots,\boldsymbol\beta_m)$ 为 $W$ 的一组基。</p>
<p>那么 $T$ 的结果可以完全被 $(T\boldsymbol\alpha_i),i\in[1,n]$ 表示，而每个 $T\boldsymbol\alpha_i$ 又可以被 $\mathcal B_2$ 唯一表示。不妨设</p>
<script type="math/tex; mode=display">
T\boldsymbol\alpha_i=\sum_{j=1}^mA_{ij}\boldsymbol\beta_j</script><p>那么就称 $A_{ij}$ 为 $T$ 的矩阵表示。容易发现 $A$ 是 $n\times m$ 的矩阵。</p>
<p>线性变换是可以复合的，就像函数复合一样。而对于同一组基，复合的结果就是将两个矩阵乘起来。</p>
<h3 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h3><p>针对矩阵的运算，称 $\det(A)$ 为矩阵 $A$ 的行列式。记作：</p>
<script type="math/tex; mode=display">
\det(A)=
\begin{vmatrix}
a_{11}&a_{12}&\cdots&a_{1n}\\
a_{21}&a_{22}&\cdots&a_{2n}\\
\vdots&\vdots&\ddots&\vdots\\
a_{n1}&a_{n2}&\cdots&a_{nn}
\end{vmatrix}
=\sum_{\substack{p_1,p_2,\cdots,p_n\\\{p_i\}\text{ is a permutation}}}(-1)^{\pi(p_1,p_2,\cdots,p_n)}\prod_{i=1}^na_{ip_i}</script><p><del>（后面这是什么鬼？）</del></p>
<p>定义 $\pi(p_1,p_2,\dots,p_n)$ 为 $(p_1,p_2,\dots,p_n)$ 的逆序对数。</p>
<p>特别的：</p>
<script type="math/tex; mode=display">
\begin{vmatrix}
a&b\\
c&d
\end{vmatrix}
=ad-bc,\\
\begin{vmatrix}
a_1&a_2&a_3\\
b_1&b_2&b_3\\
c_1&c_2&c_3
\end{vmatrix}
=(a_1b_2c_3+a_2b_3c_1+a_3b_1c_2)-(a_1b_3c_2+a_2b_1c_3+a_3b_2c_1)</script><p>（这两个比较小，可以记住）</p>
<h3 id="范德蒙矩阵行列式和循环矩阵行列式"><a href="#范德蒙矩阵行列式和循环矩阵行列式" class="headerlink" title="范德蒙矩阵行列式和循环矩阵行列式"></a>范德蒙矩阵行列式和循环矩阵行列式</h3><script type="math/tex; mode=display">
\begin{vmatrix}
1&1&\cdots&1\\
x_1&x_2&\cdots&x_n\\
x_1^2&x_2^2&\cdots&x_n^2\\
\vdots&\vdots&\ddots&\vdots\\
x_1^n&x_2^n&\cdots&x_n^n
\end{vmatrix}
=\prod_{1\le j<i\le n}(x_i-x_j)</script><script type="math/tex; mode=display">
\begin{vmatrix}
a_1&a_2&\cdots&a_n\\
a_n&a_{1}&\cdots&a_{n-1}\\
a_{n-1}&a_{n}&\cdots&a_{n-2}\\
\vdots&\vdots&\ddots&\vdots\\
a_2&a_3&\cdots&a_1
\end{vmatrix}
=\prod_{i=1}^nf(\omega_i)</script><p>其中 $f(x)=\sum\limits_{i=0}^{n-1}a_{i+1}x^i$，$\omega_i^n=1,\omega_i\in\mathbf C$。</p>
<h2 id="特征值、特征向量、特征多项式"><a href="#特征值、特征向量、特征多项式" class="headerlink" title="特征值、特征向量、特征多项式"></a>特征值、特征向量、特征多项式</h2><p>这里只考虑方阵的情况，即 $A$ 是 $n$ 个向量向 $n$ 个向量的线性变换。</p>
<p>如果向量 $\boldsymbol x$ 满足 $A\boldsymbol x=\lambda\boldsymbol x$，则称 $\boldsymbol x$ 为 $A$ 的特征向量而 $\lambda$ 为 $A$ 的特征值。</p>
<p>注意到 $\lambda$ 实际上描述了一个方程 $(A-\lambda I)\boldsymbol x=\boldsymbol 0$，这样的方程的解 $\boldsymbol x$ 构成了一个线性空间，称这个空间为 $\lambda$ 对应的特征向量空间。</p>
<p>同时当 $\lambda=0$ 时这个空间为零空间（其实就是 $A\boldsymbol x=\boldsymbol b$ 的解向量空间），其维度记作 $\operatorname{null}(A)$。有性质</p>
<script type="math/tex; mode=display">
\operatorname{null}(A)+\operatorname{rank}(A)=\dim(A)</script><p>其中 $\operatorname{rank}(A)$ 称为矩阵的<strong>秩</strong>。</p>
<p>（大概就是矩阵对应的那个方程组有多少个线性不相关的方程）</p>
<h3 id="如何解特征值"><a href="#如何解特征值" class="headerlink" title="如何解特征值"></a>如何解特征值</h3><p>我们发现 $\det(A-\lambda I)=0$。因此我们将 $\det(A-\lambda I)$ 看做关于 $\lambda$ 的 $n$ 次多项式，这个多项式的根就是全体特征值。这个多项式也被称为特征多项式。</p>
<h2 id="Matrix-Tree-定理"><a href="#Matrix-Tree-定理" class="headerlink" title="Matrix-Tree 定理"></a>Matrix-Tree 定理</h2><p>定义一个图的基尔霍夫矩阵为 $K=D-A$，其中 $D$ 是度数矩阵，$A$ 是邻接矩阵。</p>
<p>任意去掉 $i$ 行 $j$ 列，剩余矩阵的 $\det$ 就是生成树的个数。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN-diy">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/05/09/%E8%99%9A%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Qinshihuang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qinshihuang's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/09/%E8%99%9A%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">虚树学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-05-09 21:07:23 / 修改时间：21:47:21" itemprop="dateCreated datePublished" datetime="2024-05-09T21:07:23+08:00">2024-05-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>虚树是一种减少冗余、优化时间复杂度的树上问题优化。</p>
<p>在解决某些树上问题时，如果在多次询问中点数总体很大，但是解决问题的“关键点”数量很少，就可以利用虚树来将无用的点“剔除”，从而减少时间浪费。</p>
<h1 id="构造虚树的方法"><a href="#构造虚树的方法" class="headerlink" title="构造虚树的方法"></a>构造虚树的方法</h1><p>一般来说令关键点集合为 $V$，那么虚树包含着所有关键点和它们的 $\mathrm{LCA}$。虚树的边<strong>直接连接</strong> $\mathrm{LCA}$ 和下面的点，而不再关心中间经过的点。</p>
<p>而构造虚树的一种常用做法就是<strong>利用单调栈维护虚树上的一条链</strong>。</p>
<p>记 $st_1$ 为栈顶元素，$st_2$ 为栈中第二个元素，以此类推。</p>
<ul>
<li>首先我们发现虚树中的点只要祖先顺序不发生变化就可以任意地放点。所以为了方便我们先将根节点 $1$ 放入栈。</li>
<li>接下来，我们将 $V$ 中的元素按照 $\mathrm{dfn}$ 序排序。并依次插入单调栈。</li>
<li>第 $i$ 次插入中，我们记 $l=\operatorname{LCA}(p_i,st_1)$。<ul>
<li>如果 $l=st_1$，说明 $p_i$ 接在 $st_1$ 下面，那么说明还没有更换链，直接将 $p_i$ 压入栈中。</li>
<li>如果 $l\neq st_1$，说明更换了链，那么就判断 $st_2$ 的 $\mathrm{dfn}$ 和 $l$ 的 $\mathrm{dfn}$ 的大小关系（不用担心只有一个元素，因为 $1$ 一直在栈中）。如果 $\mathrm{dfn}_l&lt;\mathrm{dfn}_{st_2}$，就说明这个新链的起始点仍然在 $st_2$ 之上，那么可以直接弹出 $st_1$ 并建边。如果 $\mathrm{dfn}_l\ge\mathrm{dfn}_{st_2}$，就说明 $st_2$ 已经比新链高了。这时候如果 $\mathrm{dfn}_l=\mathrm{dfn}_{st_2}$，则说明 $st_2$ 恰好是新链的起始点，就可以直接压栈了；否则还需将 $st_1$ 弹出后将 $l$ 压入栈中。</li>
</ul>
</li>
<li>最后在栈中还会剩下一条链，此时直接建边即可。</li>
</ul>
<p>容易发现，这个过程的时间复杂度是 $O(n\log n)$ 的（$n$ 为<strong>关键点总数</strong>）。</p>
<h1 id="例题：P2495-消耗战"><a href="#例题：P2495-消耗战" class="headerlink" title="例题：P2495 消耗战"></a>例题：P2495 消耗战</h1><p>首先想一下朴素 dp 怎么做。</p>
<p>不妨设 $dp_u$ 为使 $u$ 与子树中能源节点分离所需的最少代价，并设 $E$ 为能源节点集合。那么可得转移方程为</p>
<script type="math/tex; mode=display">dp_u=\sum_{v\in\text{son }u}\begin{cases}\min\{dp_v,w(u,v)\},&v\not\in E\\w(u,v),&v\in E\end{cases}</script><p>其中 $w(u,v)$ 为连接 $u,v$ 的边权。</p>
<p>这样子 dp 一次的时间复杂度是 $O(n)$ 的，总时间复杂度 $O(nq)$ 肯定过不了。</p>
<p>我们发现 $\sum|E|$ 比较小，所以考虑对每次询问，对 $E$ 中的节点建出虚树来，并在虚树上跑 dp。此时虚树的边权应为原树中两点路径上边权的最小值。</p>
<p>这样就过了，时间复杂度。。。$O(\sum|E|\log n)$。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN-diy">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/05/09/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B8%8E%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Qinshihuang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qinshihuang's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/09/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B8%8E%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">多项式与生成函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-05-09 21:06:41 / 修改时间：21:46:20" itemprop="dateCreated datePublished" datetime="2024-05-09T21:06:41+08:00">2024-05-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><del>咍咍。</del></p>
<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><ul>
<li>复数。</li>
<li>微积分。</li>
<li>泰勒展开。</li>
<li>牛顿迭代。</li>
<li><del>多项式加法</del>。</li>
</ul>
<h1 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h1><p>定义 $n$ 阶单位根为 $\mathbf C$ 内 $x^n=1$ 的根，记作 $\omega_1,\omega_2,\dots,\omega_n$，其中 $\omega_n=1$。</p>
<p>不难发现如果按照辐角主值排序那么 $\omega_2=\omega_1^2,\omega_3=\omega_1^3\dots$，同时还可以得到计算 $\omega$ 的公式：</p>
<script type="math/tex; mode=display">
\omega_k=\cos\dfrac{2\pi}{k}+\mathrm i\sin\dfrac{2\pi}{k}</script><p>原因很简单，$1=\omega_1^n=\angle2\pi$，因此 $\arg(\omega_1)=\dfrac{2\pi}{n}$，进而推得其他单位根。</p>
<p>以下记 $n$ 阶本源单位根 $\omega_n=\cos\dfrac{2\pi}{n}+\mathrm i\sin\dfrac{2\pi}{n}$。</p>
<p>注意到多项式乘法的定义说明了由点值表示到点值表示的乘法是 $O(n)$ 的。因此我们考虑快速实现一般多项式表示与点值表示的转换。</p>
<p>我们考虑</p>
<script type="math/tex; mode=display">
f(x)=\sum_{k=0}^{n-1}a_kx^k</script><p>那么</p>
<script type="math/tex; mode=display">
f(\omega_n)=\sum_{k=0}^{n-1}a_k\omega_n^k\\
f(\omega_n^2)=\sum_{k=0}^{n-1}a_k\omega_n^{2k}\\
f(\omega_n^3)=\sum_{k=0}^{n-1}a_k\omega_n^{3k}\\
\cdots\\
f(\omega_n^n)=\sum_{k=0}^{n-1}a_k\omega_n^{nk}=\sum_{i=0}^{n-1}a_i</script><p>我们不妨令 $b_k=f(\omega_n^k)$，并且构造一个新的多项式 $g(x)=\sum\limits_{k=0}^{n-1}b_kx^k$，那么将单位根的共轭复数带入得到：</p>
<script type="math/tex; mode=display">
\begin{aligned}
g(\omega_n^{-1})&=\sum_{k=0}^{n-1}\omega_{n}^{-k}\sum_{l=0}^{n-1}a_l\omega_n^{kl}\\
&=\sum\begin{pmatrix}a_0&a_0\omega_n^{-1}&a_0\omega_n^{-2}&\cdots&a_0\omega_n^{-(n-1)}\\
a_1&a_1&a_1&\cdots&a_1\\
a_2&a_2\omega_n&a_2\omega_n^2&\cdots&a_2\omega_n^{n-1}\\
\vdots&\vdots&\vdots&&\vdots\\
a_n&a_n\omega_n^{n-1}&a_n\omega_n^{n-2}&\cdots&a_n\omega_n
\end{pmatrix}\\
&=\sum_{k=0}^{n-1}[k=1]na_k=na_1
\end{aligned}</script><p>这里用到了单位根</p>
<script type="math/tex; mode=display">\sum_{k=0}^{n-1}\omega_n^{ck}=0</script><p>的性质。利用向量等知识证明不难。</p>
<p>（那个 $\sum(\text{bla})$ 就是表示对那些东西求和，因为我感觉写成矩阵形式更加直观。）</p>
<p>类似的，我们可以得到 $g(\omega_n^{-2})=na_2,\cdots,g(\omega_n^{-k})=na_k$。这样，将单位根作为点值表示有天然的优势：它天生支持逆变换。</p>
<p>而 <strong>FFT 算法</strong>正是利用了单位根的这一性质，又增加上了分治优化而允许我们在 $O(n2^n)$ 的时间复杂度内完成度数为 $2^n$ 的多项式的点值/一般多项式表示相互转化。</p>
<p>具体的，设多项式 $A(x)=\sum\limits_{k=0}^{n-1}a_kx^k$。我们将 $A(x)$ 分成两部分：</p>
<script type="math/tex; mode=display">
A(x)=\sum_{i=0}^{\frac n2-1}a_{2i}x^{2i}+x\sum_{i=0}^{\frac n2-1}a_{2i+1}x^{2i}</script><p>并记这两部分分别为 $A_1(x^2),A_2(x^2)$，也就是说 $A(x)=A_1(x^2)+xA_2(x^2)$。</p>
<p>现在让我们看看如果把 $\omega_n^i$ 带入会发生什么。</p>
<script type="math/tex; mode=display">
A(\omega_n^i)=A_1(\omega_{n/2}^i)+\omega_{n}^iA_2(\omega_{n/2}^i)</script><p>好了，$A$ 被分成了两个结构相同的子问题，这就可以使用分治/迭代实现，从而做到 $O(n\log n)$ 的时间复杂度。</p>
<p>核心代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">il <span class="type">void</span> <span class="title">fft</span><span class="params">(cp *a,<span class="type">int</span> inv)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lim;i++) <span class="keyword">if</span>(i&lt;r[i]) <span class="built_in">swap</span>(a[i],a[r[i]]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;lim;mid&lt;&lt;=<span class="number">1</span>) &#123;</span><br><span class="line">		cp wn=<span class="built_in">cp</span>(<span class="built_in">cos</span>(pi/mid),inv*<span class="built_in">sin</span>(pi/mid));</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> R=mid&lt;&lt;<span class="number">1</span>,j=<span class="number">0</span>;j&lt;lim;j+=R) &#123;	<span class="comment">//迭代减常数</span></span><br><span class="line">			cp w=<span class="built_in">cp</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;mid;k++,w=w*wn) &#123;</span><br><span class="line">				cp x=a[j+k],y=w*a[j+mid+k];	<span class="comment">//蝴蝶变换减常数。其实就是减少计算次数啦（</span></span><br><span class="line">				a[j+k]=x+y;</span><br><span class="line">				a[j+mid+k]=x-y;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="NTT"><a href="#NTT" class="headerlink" title="NTT"></a>NTT</h2><p>一般的多项式题里都会有取模。而 FFT 在取模下一无是处，因此要使用在模意义下的算法 NTT。</p>
<p>其实 NTT 就是把单位根 $\omega_n$ 换成了原根的幂 $g_n=g^{\frac{p-1}{n}}$。</p>
<p>我们需要使得这个新的替代品在模意义下与单位根的性质相同。</p>
<p>首先</p>
<script type="math/tex; mode=display">
g_n^n\equiv g^{p-1}\equiv 1\pmod p</script><p>这是原根的性质之一。</p>
<p>其次</p>
<script type="math/tex; mode=display">
g_n^{\frac{n}{2}}\equiv g^{\frac{p-1}{2}}\pmod p</script><p>而 $\left(g^{\frac{p-1}{2}}\right)^2\equiv g^{p-1}\equiv1\pmod p$，但 $g,g^2,\dots,g^{p-1}$ 模 $p$ 两两不同余，因此 $g_n^{\frac{n}{2}}\equiv-1\pmod p$。</p>
<p>最后</p>
<script type="math/tex; mode=display">
\left(g_n^{k+\frac{n}{2}}\right)^2\equiv g_n^{2k+n}\equiv g_n^{2k}\pmod p</script><p>因此我们发现 $g_n$ 在模意义下与 $\omega_n$ 是等价的，可以直接替代。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">il <span class="type">void</span> <span class="title">ntt</span><span class="params">(ll *A,ll inv)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lim;i++) <span class="keyword">if</span>(i&lt;r[i]) <span class="built_in">swap</span>(A[i],A[r[i]]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> mid=<span class="number">1</span>;mid&lt;lim;mid&lt;&lt;=<span class="number">1</span>) &#123;</span><br><span class="line">		ll gn=<span class="built_in">qpow</span>(inv==<span class="number">1</span>?g:invg,(mod<span class="number">-1</span>)/(mid&lt;&lt;<span class="number">1</span>));</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> R=mid&lt;&lt;<span class="number">1</span>,j=<span class="number">0</span>;j&lt;lim;j+=R) &#123;</span><br><span class="line">			ll G=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;mid;k++,G=(G*gn)%mod) &#123;</span><br><span class="line">				ll x=A[j+k]%mod,y=G*A[j+mid+k]%mod;</span><br><span class="line">				A[j+k]=(x+y)%mod;</span><br><span class="line">				A[j+mid+k]=(x-y+mod)%mod;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>附：常用分治模数及其最小原根。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">模数</th>
<th style="text-align:center">分解</th>
<th style="text-align:center">$g$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$65537$</td>
<td style="text-align:center">$2^{16}+1$</td>
<td style="text-align:center">$3$</td>
</tr>
<tr>
<td style="text-align:center">$469762049$</td>
<td style="text-align:center">$2^{26}\times7$</td>
<td style="text-align:center">$3$</td>
</tr>
<tr>
<td style="text-align:center">$998244353$</td>
<td style="text-align:center">$2^{23}\times 7\times 17+1$</td>
<td style="text-align:center">$3$</td>
</tr>
<tr>
<td style="text-align:center">$1004535809$</td>
<td style="text-align:center">$2^{21}\times479+1$</td>
<td style="text-align:center">$3$</td>
</tr>
</tbody>
</table>
</div>
<h1 id="多项式求逆"><a href="#多项式求逆" class="headerlink" title="多项式求逆"></a>多项式求逆</h1><p>定义：多项式 $f(x)$ 的逆为另一个多项式 $g(x)$ 满足</p>
<script type="math/tex; mode=display">
f(x)g(x)=1</script><p>求满足条件的多项式 $f(x)g(x)\equiv 1\pmod{x^n}$，系数对 $998244353$ 取模。</p>
<p>我们考虑递归求解。</p>
<p>不妨设我们知道了一个多项式 $G(x)$ 使得 $f(x)G(x)\equiv1\pmod{x^{\frac{n}{2}}}$。</p>
<p>那么考虑做差</p>
<script type="math/tex; mode=display">
\begin{aligned}
f(x)[g(x)-G(x)]&\equiv 0\pmod{x^{\frac{n}{2}}}\\
g(x)-G(x)&\equiv 0\pmod{x^{\frac{n}{2}}}\\
[g(x)-G(x)]^2&\equiv 0\pmod{x^n}\\
g^2(x)-2g(x)G(x)+G^2(x)&\equiv 0\pmod{x^n}
\end{aligned}</script><p>两边同时乘上 $f(x)$，根据定义有</p>
<script type="math/tex; mode=display">
g(x)-2G(x)+f(x)G^2(x)\equiv0\pmod{x^n}\\</script><p>化简得</p>
<script type="math/tex; mode=display">
g(x)\equiv G(x)[2-f(x)G(x)]\pmod{x^n}</script><p>可用 NTT 求解。递归单层时间复杂度是 $O(n\log n)$，可知总时间复杂度仍为 $O(n\log n)$。</p>
<p>核心代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">il <span class="type">void</span> <span class="title">solve</span><span class="params">(ll len,ll *a,ll *b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(len==<span class="number">1</span>) &#123;</span><br><span class="line">		b[<span class="number">0</span>]=<span class="built_in">qpow</span>(a[<span class="number">0</span>],mod<span class="number">-2</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">solve</span>((len+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>,a,b);</span><br><span class="line">	lim=<span class="number">1</span>,cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(lim&lt;(len&lt;&lt;<span class="number">1</span>)) &#123;</span><br><span class="line">		lim&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">		cnt++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lim;i++) r[i]=(r[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(cnt<span class="number">-1</span>));</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++) c[i]=a[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=len;i&lt;=lim;i++) c[i]=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">NTT</span>(c,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">NTT</span>(b,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lim;i++) b[i]=<span class="number">1ll</span>*(<span class="number">2ll</span>-b[i]*c[i]%mod+mod)%mod*b[i]%mod;</span><br><span class="line">	<span class="built_in">NTT</span>(b,<span class="number">-1</span>);</span><br><span class="line">	<span class="type">int</span> invl=<span class="built_in">qpow</span>(lim,mod<span class="number">-2</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++) b[i]=<span class="number">1ll</span>*b[i]*invl%mod;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=len;i&lt;lim;i++) b[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="多项式对数函数"><a href="#多项式对数函数" class="headerlink" title="多项式对数函数"></a>多项式对数函数</h1><blockquote>
<p>在模 $x^n$ 意义下求一个多项式 $g(x)$ 使得</p>
<script type="math/tex; mode=display">
g(x)\equiv\ln f(x)</script><p>系数对 $9998244353$ 取模。</p>
</blockquote>
<p>对这个式子做些变换：</p>
<script type="math/tex; mode=display">
\begin{aligned}
g(x)&\equiv \ln f(x)\\
\dfrac{\mathrm d}{\mathrm dx}g(x)&\equiv\dfrac{\mathrm{d}}{\mathrm dx}[\ln f(x)]\\
\dfrac{\mathrm d}{\mathrm dx}g(x)&\equiv \dfrac{f^\prime(x)}{f(x)}\\
g(x)&\equiv\int\dfrac{f^\prime(x)}{f(x)}\mathrm dx
\end{aligned}</script><p>直接求导、求逆、乘起来再积回去就可以了，时间复杂度仍然是 $O(n\log n)$。</p>
<p>核心代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">getInv</span>(n,a,inva);</span><br><span class="line">ll lim=<span class="number">1</span>,cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(lim&lt;(n&lt;&lt;<span class="number">1</span>)) &#123;</span><br><span class="line">	lim&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">	cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lim;i++) r[i]=(r[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(cnt<span class="number">-1</span>));</span><br><span class="line"><span class="built_in">NTT</span>(da,lim,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">NTT</span>(inva,lim,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lim;i++) ans[i]=da[i]*inva[i]%mod;</span><br><span class="line"><span class="built_in">NTT</span>(ans,lim,<span class="number">-1</span>);</span><br><span class="line">ll invl=<span class="built_in">qpow</span>(lim,mod<span class="number">-2</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) ans[i]=ans[i]*invl%mod;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--) ans[i]=ans[i<span class="number">-1</span>]*<span class="built_in">qpow</span>(i,mod<span class="number">-2</span>)%mod;</span><br><span class="line">ans[<span class="number">0</span>]=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h1 id="多项式指数"><a href="#多项式指数" class="headerlink" title="多项式指数"></a>多项式指数</h1><blockquote>
<p>给定多项式 $f(x)$，在模 $x^n$ 意义下求 $g(x)$ 使得</p>
<script type="math/tex; mode=display">
g(x)\equiv\mathrm e^{f(x)}\pmod{x^n}</script></blockquote>
<h2 id="牛顿迭代"><a href="#牛顿迭代" class="headerlink" title="牛顿迭代"></a>牛顿迭代</h2><p>前置一个知识：什么是牛顿迭代。</p>
<p>假设你要求 $\sqrt n$，一个简单的方法是二分，这样需要计算 $\log n$ 次。</p>
<p>另一个思路就是使用牛顿迭代。这个问题的本质是求解 $f(x)=x^2-n$ 的零点。我们不妨假设一个初始值 $x_0$，并求出 $f(x)$ 在 $x=x_0$ 处的切线</p>
<script type="math/tex; mode=display">
l:f^\prime(x)(x-x_0)+f(x)</script><p>与 $x$ 轴的坐标 $x_1$，最后将初始值设为 $x_1$ 继续迭代。这样做每次精度会翻倍。</p>
<p>应用在多项式也是如此。不妨设我们要求一个函数 $G(x)$ 使得对于给定的函数 $F(x)$ 有 $F(G(x))\equiv 0\pmod {x^n}$。我们假设已经知道了 $G_0(x)$ 使得 $F(G_0(x))\equiv 0\pmod{x^{\frac{n}{2}}}$，此时我们在 $G_0(x)$ 处将 $F(G(x))$ 泰勒展开：</p>
<script type="math/tex; mode=display">
F(G(x))=\sum_{k=0}^\infty\dfrac{F^{(n)}(G_0(x))\cdot(G(x)-G_0(x))^n}{n!}\equiv 0</script><p>由于 $G_0(x)\equiv G(x)\pmod{x^{\frac{n}{2}}}$，所以 $G_0^2(x)\equiv G^2(x)\pmod {x^n}$。</p>
<p>而根据二项式展开定理，</p>
<script type="math/tex; mode=display">
\begin{aligned}
(a-b)^n&\equiv\sum_{k=0}^n(-1)^k\dbinom nka^kb^{n-k}\\
&\equiv a^n-b^n\pmod n
\end{aligned}</script><p>于是得到泰勒展开式第三项往后都为 $0$，因此得到</p>
<script type="math/tex; mode=display">
F(G_0(x))+F^\prime(G_0(x))(G(x)-G_0(x))\equiv 0\pmod{x^n}</script><p>最后得到了牛顿迭代公式</p>
<script type="math/tex; mode=display">
G(x)\equiv G_0(x)-\dfrac{F(G_0(x))}{F^\prime(G_0(x))}\pmod{x^n}</script><hr>
<p>有了这个公式之后我们就可以解决我们的问题啦！</p>
<p>本题中 $g(x)\equiv \mathrm e^{f(x)}$ 等价于 $f(x)\equiv\ln g(x)$，即 $\ln g(x)-f(x)\equiv 0$。</p>
<p>因此构造函数 $A(g(x))=\ln g(x)-f(x)$，套用牛顿迭代公式可知</p>
<script type="math/tex; mode=display">
\begin{aligned}
g(x)&\equiv g_0(x)-\dfrac{A(g_0(x))}{A^\prime(g_0(x))}\\
&\equiv g_0(x)-g_0(x)[\ln g_0(x)-f(x)]\\
&\equiv g_0(x)[1-\ln g_0(x)+f(x)]\pmod {x^n}
\end{aligned}</script><p>然后就会了，一次迭代时间复杂度 $O(n\log n)$，总时间复杂度还是 $O(n\log n)$。</p>
<p>边界条件是 $n=1$，此时由于 $f_0=0$，所以 $\ln g(x)=0$，$g(0)=1$，直接返回即可。</p>
<p>核心代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">il <span class="type">void</span> <span class="title">getExp</span><span class="params">(ll len,ll *a,ll *expa,ll *lna,ll *inva)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(len==<span class="number">1</span>) &#123;</span><br><span class="line">		expa[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">getExp</span>((len+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>,a,expa,lna,inva);</span><br><span class="line">	<span class="built_in">getLn</span>(len,expa,lna,inva);</span><br><span class="line">	ll lim=<span class="number">1</span>,cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(lim&lt;(len&lt;&lt;<span class="number">1</span>)) &#123;</span><br><span class="line">		lim&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">		cnt++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++) r[i]=(r[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(cnt<span class="number">-1</span>));</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++) a1[i]=a[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=len;i&lt;lim;i++) lna[i]=a1[i]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lim;i++) a1[i]=((a1[i]-lna[i])%mod+mod)%mod;</span><br><span class="line">	a1[<span class="number">0</span>]=(a1[<span class="number">0</span>]+<span class="number">1</span>)%mod;</span><br><span class="line">	<span class="built_in">NTT</span>(a1,lim,<span class="number">1</span>);<span class="built_in">NTT</span>(expa,lim,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lim;i++) expa[i]=expa[i]*a1[i]%mod;</span><br><span class="line">	<span class="built_in">NTT</span>(expa,lim,<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=len;i&lt;lim;i++) expa[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="应用：多项式快速幂"><a href="#应用：多项式快速幂" class="headerlink" title="应用：多项式快速幂"></a>应用：多项式快速幂</h2><blockquote>
<p>给定一个多项式 $f(x)$，求模 $x^n$ 意义下 $f^k(x)$ 的值。</p>
</blockquote>
<p>暴力做法是做 $k$ 次 NTT 乘法，时间复杂度是 $O(nk\log n)$。</p>
<p>次暴力做法是快速幂上套 NTT，时间复杂度是 $O(n\log n\log k)$，但是 $k\le10^{10^5}$ 的量级让这玩意也过不去。</p>
<p>我们想一下能不能加速一下这个过程。</p>
<p>有一个公式：</p>
<script type="math/tex; mode=display">
a^b=\mathrm e^{b\ln a}</script><p>带入到多项式中也是一样的，即</p>
<script type="math/tex; mode=display">
f^k(x)=\mathrm e^{k\ln f(x)}</script><p>注意到这题 $f_0=1$，因此直接 $\ln,\exp$ 即可。</p>
<p>对于 $k$ 要在读入的时候取模的事情，因为</p>
<script type="math/tex; mode=display">
\mathrm e^x=\sum_{k=0}^{\infty}\dfrac{x^k}{k!}</script><p>直接把 $k\ln f(x)$ 带入得到</p>
<script type="math/tex; mode=display">
\mathrm e^{k\ln x}=\sum_{i=0}^\infty \dfrac{k^i\ln^ix}{i!}</script><p>这东西显然可以取模。</p>
<p>然而加强版把这个限制去掉了，怎么办呢？</p>
<p>很简单，让整个多项式的系数除以 $f_0$，这样 $f_0$ 就是 $1$ 了。</p>
<p>你说得对，但是数据里有 $f_0=0$ 的点。那就整体除以 $f_1x$。你说得对，但是数据里有 $f_0=f_1=0$ 的点。那就整体除以 $f_2x^2$……</p>
<p>直到得到一个常数项为 $1$ 的多项式之后直接做就可以了。时间复杂度是 $O(n\log n)$。</p>
<h1 id="生成函数"><a href="#生成函数" class="headerlink" title="生成函数"></a>生成函数</h1><p>前置知识：</p>
<ul>
<li>多项式。</li>
<li>组合数学。</li>
<li>推式子。</li>
</ul>
<h2 id="什么是生成函数"><a href="#什么是生成函数" class="headerlink" title="什么是生成函数"></a>什么是生成函数</h2><p>考虑如下的一个数列</p>
<script type="math/tex; mode=display">
a=\left<a_0,a_1,a_2\dots\right></script><p>当然可以写成这样的形式，但是另一种方式是将其写成<strong>生成函数</strong>的形式（普通生成函数），即</p>
<script type="math/tex; mode=display">
A(z)=\sum_{k=0}^{\infty}a_kz^k</script><p>这里 $z$ 起到了一个占位符的作用，与一般意义上函数自变量不同。<del>当然也可以当函数自变量理解啦</del></p>
<p>对于一个生成函数 $A(z)$，取其 $z^n$ 项上的系数 $a_n$，记作 $[z^n]A(z)$。</p>
<p>生成函数相加是可行的，即</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\left<a_0,a_1,\dots\right>+\left<b_0,b_1,\dots\right>\\
=&A(z)+B(z)=\sum_{k=0}^\infty(a_k+b_k)z^k\\
=&\left<a_0+b_0,a_1+b_1,\dots\right>
\end{aligned}</script><p>但是这种形式幂级数不方便计算，一般来说我们要将其写成<strong>封闭形式</strong>。</p>
<p>例如，对于序列 $a=\left<1,1,1,\dots\right>$ 的生成函数 $A(z)=\sum\limits_{k=0}^\infty z^i$，我们可以发现</p>
<script type="math/tex; mode=display">
\begin{aligned}
1+z\cdot A(z)&=z+\sum_{k=1}^\infty z^k\\
&=\sum_{k=0}^\infty z^k=A(z)
\end{aligned}</script><p>因此 $(1-z)A(z)=1$，得到 $A(z)$ 的封闭形式</p>
<script type="math/tex; mode=display">
A(z)=\dfrac 1{1-z}</script><p>类似的，我们可以得到如下公式：</p>
<script type="math/tex; mode=display">
\dfrac{1}{1-az}=\sum_{k=0}^\infty a^kz^{k}</script><hr>
<p>事实上 $A(z)$ 的意义不止于此。考虑另一个生成函数 $B(z)=\sum\limits_{k=0}^\infty b_kz^k$，如果将这两个函数乘起来，可以得到一个新的函数 $C(z)$。看看这个 $C(z)$ 是什么：</p>
<script type="math/tex; mode=display">
[z^n]C(z)=\sum_{k=0}^nb_k\cdot a_{n-k}=\sum_{k=0}^nb_k</script><p>所以说 $C(z)$ 的系数是 $B(z)$ 的系数前缀和。这是相当有用的。</p>
<blockquote>
<p>另外我们也可以发现 $A(z)$ 的乘法逆 $A^{-1}(z)=1-z$ 就是差分运算。</p>
</blockquote>
<p>根据这个例子，我们发现生成函数的卷积就是将 $A$ 中的 $z^0,z^1,\dots,z^n$ 项与 $B$ 中的 $z^n,z^{n-1},\dots,z^0$ 项相搭配得到新的系数。</p>
<h2 id="生成函数能干什么"><a href="#生成函数能干什么" class="headerlink" title="生成函数能干什么"></a>生成函数能干什么</h2><h3 id="推数列通项"><a href="#推数列通项" class="headerlink" title="推数列通项"></a>推数列通项</h3><p>不妨拿斐波那契数列举例子。</p>
<p>众所周知，$f_1=f_2=1,f_n=f_{n-1}+f_{n-2}\ (n\ge3)$ 这个数列就是斐波那契数列。现在我们想要它的通项公式。</p>
<p>如果你背过了，就知道</p>
<script type="math/tex; mode=display">
f_n=\dfrac{1}{\sqrt5}\left[\left(\dfrac{1+\sqrt5}2\right)^n-\left(\dfrac{1-\sqrt5}2\right)^n\right]</script><p>但这是怎么推出来的呢？</p>
<p>不妨把斐波那契数列的生成函数写出来：</p>
<script type="math/tex; mode=display">
F(z)=\sum_{k=1}^\infty f_kz^k</script><p>我们希望先找到它的封闭形式。</p>
<script type="math/tex; mode=display">
\begin{aligned}
z^2\cdot F(z)&=\sum_{k=3}^\infty f_{k-2}z^k\\
z\cdot F(z)&=\sum_{k=2}^\infty f_{k-1}z^k\\
(z^2+z)F(z)&=f_1z^2+\sum_{k=3}^\infty f_kz^k\\
(z^2+z)F(z)+f_1z&=F(z)\\
F(z)&=\dfrac{z}{1-z-z^2}
\end{aligned}</script><p>然后考虑取 $[z^n]F(z)$。我们考虑使用以前知道的公式进行求解。</p>
<p>我们不妨设 $F(z)=\dfrac{c}{1-az}+\dfrac{d}{1-bz}$。</p>
<p>开始推式子：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\dfrac{c}{1-az}+\dfrac{d}{1-bz}=\dfrac{-(ad+bc)z+c+d}{abz^2-(a+b)z+1}
\end{aligned}</script><p>对照系数可知：</p>
<script type="math/tex; mode=display">
\begin{cases}
a+b=1\\
ab=-1\\
c+d=0\\
ad+bc=-1
\end{cases}</script><p>解得</p>
<script type="math/tex; mode=display">
\begin{cases}
a=\dfrac{\sqrt5+1}{2}\\
b=\dfrac{1-\sqrt5}{2}\\
c=\dfrac{1}{a-b}\\
d=-\dfrac{1}{a-b}
\end{cases}</script><p>这里不把 $c,d$ 写出来，一部分是因为<del>难算</del>，还有一部分原因是后面会消去。</p>
<p>将结果代入得到：</p>
<script type="math/tex; mode=display">
\begin{aligned}
F(z)&=\dfrac{1}{a-b}\dfrac{1}{1-az}-\dfrac{1}{a-b}\dfrac{1}{1-bz}\\
&=\dfrac{1}{a-b}\sum_{k=0}^\infty(a^k-b^k)z^k
\end{aligned}</script><p>因此</p>
<script type="math/tex; mode=display">
[z^n]F(z)=\dfrac{a^n-b^n}{a-b}</script><p>最后把 $a,b$ 代入就得到了大名鼎鼎的公式：</p>
<script type="math/tex; mode=display">
f_n=\dfrac{1}{\sqrt5}\left[\left(\dfrac{1+\sqrt5}2\right)^n-\left(\dfrac{1-\sqrt5}2\right)^n\right]</script><hr>
<p>有意思的是，一道计算题也可以用 $F(z)$ 做。</p>
<blockquote>
<p>求证：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&0.1\\
+&0.01\\
+&0.002\\
+&0.0003\\
+&0.00005\\
+&0.000008\\
\vdots
\end{aligned}</script><p>的结果是有理数，并求出这个结果。</p>
</blockquote>
<p>其实题目就是让求</p>
<script type="math/tex; mode=display">
\sum_{k=1}^\infty\dfrac{1}{10^k}f_k=F\left(\dfrac{1}{10}\right)</script><p>代入公式得到 $F\left(\dfrac{1}{10}\right)=\dfrac{10}{89}$。答案确实是这个：</p>
<blockquote>
<p>$\dfrac{10}{89}\approx0.11235955056179775280898876404494\dots$</p>
</blockquote>
<h3 id="数数"><a href="#数数" class="headerlink" title="数数"></a>数数</h3><p>比如说你有 $3$ 种水果。苹果最多吃 $3$ 个，香蕉最多吃 $1$ 个，橘子必须吃 $4$ 的倍数个，问吃 $8943477323$ 个水果有多少种方法。怎么做？</p>
<blockquote>
<p>不是老弟，吃 $n$ 个水果的话 $n$ 要和苹果香蕉总个数模 $4$ 同余，除了吃 $0$ 个以外都只有 $2$ 种情况啊？</p>
</blockquote>
<p>额。</p>
<hr>
<p>我们写出三种水果的数量生成函数：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\mathsf{apple}(z)&=1+z+z^2+z^3=\dfrac{z^4-1}{z-1}\\
\mathsf{banana}(z)&=1+z\\
\mathsf{orange}(z)&=\sum_{k=0}^\infty z^{4k}=\dfrac{1}{1-z^4}
\end{aligned}</script><p>直接卷起来，得到答案生成函数：</p>
<script type="math/tex; mode=display">
\mathsf{ans}(z)=\dfrac{1+z}{1-z}</script><p>展开得到：</p>
<script type="math/tex; mode=display">
\mathsf{ans}=\left<1,2,2,2,\dots\right></script><p>bruh.</p>
<p>什么考场上生成函数太大了没法得到封闭形式？</p>
<p>这时候多项式算法就派上用场了。你直接写出形式幂级数，对 $z^n$ 取模就可以得到 $z^0,z^1,\dots,z^{n-1}$ 的系数。而这东西拿多项式写是 $O(n\log n)$ 的。也就是说你可以直接操纵生成函数了！</p>
<h3 id="例题：P4389"><a href="#例题：P4389" class="headerlink" title="例题：P4389"></a>例题：P4389</h3><blockquote>
<p>完全背包，但是 $n,m,v_i\le10^5$，对每个 $1\le s\le m$ 求装到 $s$ 体积的方案数。模 $998244353$。</p>
</blockquote>
<p>首先跑个 dp $O(nm)$。</p>
<p>注意到对于一个体积为 $v$ 的物品它的生成函数是</p>
<script type="math/tex; mode=display">
f_v(z)=1+z^v+z^{2v}+\cdots=\sum_{k=0}^\infty z^{kv}=\dfrac{1}{1-z^v}</script><p>因此我们可以简单地将 $1-z^{v_i}$ 卷积起来再求个逆，时间复杂度是……$O(nm\log m)$。: (</p>
<p>直接卷积不可行，考虑先求 $\ln$，系数加起来，再 $\exp$ 回去。这样的时间复杂度是……$O(nm\log m)$。:&lt;</p>
<p>我们看看能不能直接求出 $\ln(1-z^c)$。</p>
<script type="math/tex; mode=display">
\begin{aligned}
f(x)&=\ln(1-z^c)\\
\dfrac{\mathrm d}{\mathrm dx}f(x)&=-\dfrac{cz^{c-1}}{1-z^c}=-\sum_{k=0}^\infty z^{(k+1)c-1}\\
f(x)&=-\sum_{k=0}^\infty \dfrac{1}{k+1}z^{(k+1)c}
\end{aligned}</script><p>发现这个东西模 $x^{m+1}$ 意义下只有 $O\left(\dfrac{m}{c}\right)$ 个点有值，就做完了，直接预处理出 $\ln ans$，时间复杂度 $O(m\ln m)$。最后 $\exp$ 回去即可得到答案。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN-diy">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/26/%E6%9D%8E%E8%B6%85%E7%BA%BF%E6%AE%B5%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Qinshihuang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qinshihuang's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/26/%E6%9D%8E%E8%B6%85%E7%BA%BF%E6%AE%B5%E6%A0%91/" class="post-title-link" itemprop="url">李超线段树</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-26 21:36:54" itemprop="dateCreated datePublished" datetime="2024-04-26T21:36:54+08:00">2024-04-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-09 21:48:57" itemprop="dateModified" datetime="2024-05-09T21:48:57+08:00">2024-05-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="模板-P4097"><a href="#模板-P4097" class="headerlink" title="模板 P4097"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4097">模板 P4097</a></h1><p>有 $n$ 次操作，每次操作如下：</p>
<ol>
<li>在平面内插入一条线段。</li>
<li>查询某点最高的线段高度。</li>
</ol>
<p>时间复杂度 $O(n\log^2 n)$，强制在线。</p>
<hr>
<p>李超线段树模板题，核心思想是标记永久化。</p>
<p>首先在线段树的每个节点记录当前节点的“优势线段”，即在区间中点高度最高的线段编号。</p>
<p>初始时优势线段标号为 $0$。</p>
<p>在修改时，对于当前修改到的区间和目标的区间，若他们相等，则插入线段；否则就拆分区间递归向下搜索，这些部分和正常线段树一样。</p>
<p>考虑插入线段到区间怎么写。</p>
<p>首先若当前即将插入的线段的中点高度高于优势线段的高度，那么当前线段可以<strong>取代</strong>优势线段，此时应该<strong>交换</strong>这两条线段。至于为什么后面有用处。</p>
<p>其次判断有没有递归向下修改的意义。可以发现若<strong>当前的优势线段</strong>左右高度均高于修改的线段，那么就没有修改的意义了。</p>
<blockquote>
<p>这里，当前优势线段和修改的线段都是<strong>已经交换完</strong>后的线段，这也是交换的意义，可以减少很多代码编写的难度。</p>
</blockquote>
<p>可以发现两条线段只有一个交点，所以最多只有一半区间需要被继续修改，可以发现是有交点的一半需要继续修改，此时根据两端高度来判断哪边有交点即可。</p>
<blockquote>
<p>其实判断哪边有交点是需要根据斜率来综合分类讨论的，但是注意<strong>优势线段的中点要比当前线段的中点要高</strong>，这样只需要找到哪边优势线段要比当前线段低就可以判定哪边有交点了。这也体现出前边交换两条线段的目的。</p>
</blockquote>
<p>最后查询时要注意当目前插入的线段成为优势线段时，它不会继续向下递归，而是换成被替换的“前优势线段”进行递归，也就是当前线段被固定了。所以在查询时需要在沿路的所有线段中找最高点。</p>
<p>时间复杂度：每条线段都会在线段树上被分解成 $O(\log n)$ 个区间，每个区间最多会往下修改 $O(\log n)$ 次，所以总时间复杂度时 $O(n\log^2 n)$。</p>
<p>特别的，如果插入直线，只需要 $O(n\log n)$。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> il inline</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> db double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc(x) (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc(x) (x&lt;&lt;1)|1</span></span><br><span class="line"><span class="function">il ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>) &#123;f=<span class="number">-1</span>;&#125; c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>);c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> db eps=<span class="number">1e-8</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> n=<span class="number">39989</span>;</span><br><span class="line"><span class="type">const</span> db inf=<span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Line</span> &#123;</span><br><span class="line">	db k,b;</span><br><span class="line">	<span class="type">int</span> id;</span><br><span class="line">	<span class="built_in">Line</span>() &#123;&#125;</span><br><span class="line">	<span class="built_in">Line</span>(db x1,db y1,db x2,db y2,<span class="type">int</span> i) &#123;</span><br><span class="line">		id=i;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">fabs</span>(x1-x2)&lt;eps) &#123;</span><br><span class="line">			k=<span class="number">0.0</span>,b=<span class="built_in">max</span>(y1,y2);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		k=(y1-y2)/(x1-x2);</span><br><span class="line">		b=y1-k*x1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sgt</span> &#123;</span><br><span class="line">	<span class="type">int</span> maxn;</span><br><span class="line">&#125;;</span><br><span class="line">sgt tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> q,lans=<span class="number">0</span>;</span><br><span class="line">Line a[N];</span><br><span class="line"><span class="function">il db <span class="title">f</span><span class="params">(<span class="type">int</span> i,db x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a[i].k*x+a[i].b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> nl,<span class="type">int</span> nr,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> now,<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==nl&amp;&amp;r==nr) &#123;</span><br><span class="line">		<span class="keyword">if</span>(tr[now].maxn==<span class="number">0</span>) &#123;</span><br><span class="line">			tr[now].maxn=id;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">fabs</span>(<span class="built_in">f</span>(tr[now].maxn,mid)-<span class="built_in">f</span>(id,mid))&lt;eps) &#123;</span><br><span class="line">			<span class="keyword">if</span>(tr[now].maxn&gt;id) <span class="built_in">swap</span>(id,tr[now].maxn);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">f</span>(tr[now].maxn,mid)-<span class="built_in">f</span>(id,mid)&lt;=-eps) <span class="built_in">swap</span>(tr[now].maxn,id);</span><br><span class="line">		<span class="type">bool</span> fl=(<span class="built_in">f</span>(tr[now].maxn,l)-<span class="built_in">f</span>(id,l)&gt;=eps);</span><br><span class="line">		<span class="type">bool</span> fr=(<span class="built_in">f</span>(tr[now].maxn,r)-<span class="built_in">f</span>(id,r)&gt;=eps);</span><br><span class="line">		<span class="keyword">if</span>(fl&amp;&amp;fr) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span>(!fl) <span class="built_in">modify</span>(nl,mid,l,mid,<span class="built_in">lc</span>(now),id);</span><br><span class="line">		<span class="keyword">if</span>(!fr) <span class="built_in">modify</span>(mid+<span class="number">1</span>,nr,mid+<span class="number">1</span>,r,<span class="built_in">rc</span>(now),id);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(nr&lt;=mid) <span class="built_in">modify</span>(nl,nr,l,mid,<span class="built_in">lc</span>(now),id);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(mid&lt;nl) <span class="built_in">modify</span>(nl,nr,mid+<span class="number">1</span>,r,<span class="built_in">rc</span>(now),id);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">modify</span>(nl,mid,l,mid,<span class="built_in">lc</span>(now),id),<span class="built_in">modify</span>(mid+<span class="number">1</span>,nr,mid+<span class="number">1</span>,r,<span class="built_in">rc</span>(now),id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> now)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r) <span class="keyword">return</span> tr[now].maxn;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>,ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(p&lt;=mid) ans=<span class="built_in">query</span>(p,l,mid,<span class="built_in">lc</span>(now));</span><br><span class="line">	<span class="keyword">else</span> ans=<span class="built_in">query</span>(p,mid+<span class="number">1</span>,r,<span class="built_in">rc</span>(now));</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">fabs</span>(<span class="built_in">f</span>(tr[now].maxn,p)-<span class="built_in">f</span>(ans,p))&lt;eps) <span class="keyword">return</span> <span class="built_in">min</span>(tr[now].maxn,ans);</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">f</span>(tr[now].maxn,p)-<span class="built_in">f</span>(ans,p)&gt;=eps) <span class="keyword">return</span> tr[now].maxn;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> tot=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	a[<span class="number">0</span>].k=a[<span class="number">0</span>].b=-inf;</span><br><span class="line">	q=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++) &#123;</span><br><span class="line">		<span class="type">int</span> opt=<span class="built_in">read</span>();</span><br><span class="line">		<span class="keyword">if</span>(opt==<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="type">int</span> k=(<span class="built_in">read</span>()+lans<span class="number">-1</span>)%n+<span class="number">1</span>;</span><br><span class="line">			lans=<span class="built_in">query</span>(k,<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,lans);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="type">int</span> x0=(<span class="built_in">read</span>()+lans<span class="number">-1</span>)%n+<span class="number">1</span>,y0=(<span class="built_in">read</span>()+lans<span class="number">-1</span>)%(<span class="number">1000000000</span>)+<span class="number">1</span>,x1=(<span class="built_in">read</span>()+lans<span class="number">-1</span>)%n+<span class="number">1</span>,y1=(<span class="built_in">read</span>()+lans<span class="number">-1</span>)%(<span class="number">1000000000</span>)+<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(x0&gt;x1) &#123;</span><br><span class="line">				<span class="built_in">swap</span>(x0,x1);</span><br><span class="line">				<span class="built_in">swap</span>(y0,y1);</span><br><span class="line">			&#125;</span><br><span class="line">			a[++tot]=<span class="built_in">Line</span>(x0,y0,x1,y1,tot);</span><br><span class="line">			<span class="built_in">modify</span>(x0,x1,<span class="number">1</span>,n,<span class="number">1</span>,tot);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4069">P4069</a></p>
<p>给定一棵 $n$ 个点的无根树，每条边有长度，每个点有一个数 $c_u$，初始为 $123456789123456789$。</p>
<p>接下来有 $m$ 个操作，两个类型：</p>
<ol>
<li>对 $s$ 到 $t$ 的路径实施操作，对于所有在路径上的点 $u$，记 $dis_u$ 为 $s$ 到 $u$ 的距离，将 $a_u\leftarrow\min\{c_u,a\cdot dis_u+b\}$。</li>
<li>查询 $s$ 到 $t$ 路径上最小数。</li>
</ol>
<hr>
<p>看到 $a\cdot dis_u+b$ 这个形式可以想到李超树维护。</p>
<p>但是李超树插入的线段中自变量 $x$ 是单一的，但是这里 $dis_u$ 是会随着 $u$ 的变化而变化，不能直接把 $dis_u$ 作为自变量。</p>
<p>考虑变形式子，将 $s-t$ 分成 $s-\mathrm{lca}$ 和 $\mathrm{lca}-t$，记 $dep_u$ 是 $1$ 做根时 $u$ 的深度。</p>
<p>对于第一部分：</p>
<script type="math/tex; mode=display">
\begin{aligned}
a\cdot dis_u+b&=a\cdot(dep_{\mathrm{lca}}-dep_u)+b\\
&=-a\cdot dep_u+(a\cdot dep_{\mathrm{lca}}+b)
\end{aligned}</script><p>对于第二部分：</p>
<script type="math/tex; mode=display">
\begin{aligned}
a\cdot dis_u+b&=a\cdot(dep_s+dep_u-2dep_{\mathrm{lca}})+b\\
&=a\cdot dep_u+(a\cdot dep_s-2a\cdot dep_{\mathrm{lca}}+b)
\end{aligned}</script><p>这样就把会变的 $dis_u$ 变成了恒定的 $dep_u$，把这个东西作为自变量丢到李超树上就可以了。</p>
<p>这里有一个注意点：在李超树板子里求线段的高度时只需要计算 $kx+b$，但是这里的自变量是 $dep$，而且还是以线段树树剖后的 dfn 序为下标的，所以查询时要写 </p>
<script type="math/tex; mode=display">
k\cdot dep_{rev_u}+b</script><p>这样就可以了，记得开 long long。</p>
<p>注意树剖别写错。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> il inline</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc(x) (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc(x) (x&lt;&lt;1)|1</span></span><br><span class="line"><span class="function">il ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>) &#123;f=<span class="number">-1</span>;&#125; c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>);c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">	ll next,u,v,w;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sgt</span> &#123;</span><br><span class="line">	ll l,r,maxid,minn;</span><br><span class="line">&#125;;</span><br><span class="line">sgt tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">ll n,m;</span><br><span class="line">Edge edge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line">ll head[N],num_edge;</span><br><span class="line"><span class="function">il <span class="type">void</span> <span class="title">add_edge</span><span class="params">(ll u,ll v,ll w)</span> </span>&#123;</span><br><span class="line">	edge[++num_edge].next=head[u];</span><br><span class="line">	edge[num_edge].u=u,edge[num_edge].v=v,edge[num_edge].w=w;</span><br><span class="line">	head[u]=num_edge;</span><br><span class="line">&#125;</span><br><span class="line">ll fa[N],dep[N],son[N],siz[N];</span><br><span class="line">ll seg[N],rev[N],top[N],tot;</span><br><span class="line"><span class="function">il <span class="type">void</span> <span class="title">dfs1</span><span class="params">(ll u,ll f,ll ww)</span> </span>&#123;</span><br><span class="line">	fa[u]=f,dep[u]=dep[f]+ww,siz[u]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].next) &#123;</span><br><span class="line">		ll v=edge[i].v,w=edge[i].w;</span><br><span class="line">		<span class="keyword">if</span>(v==f) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs1</span>(v,u,w);</span><br><span class="line">		siz[u]+=siz[v];</span><br><span class="line">		<span class="keyword">if</span>(siz[v]&gt;siz[son[u]]) son[u]=v;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="type">void</span> <span class="title">dfs2</span><span class="params">(ll u,ll f)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(son[u]!=<span class="number">0</span>) &#123;</span><br><span class="line">		seg[son[u]]=++tot;</span><br><span class="line">		rev[tot]=son[u];</span><br><span class="line">		top[son[u]]=top[u];</span><br><span class="line">		<span class="built_in">dfs2</span>(son[u],u);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].next) &#123;</span><br><span class="line">		<span class="type">int</span> v=edge[i].v;</span><br><span class="line">		<span class="keyword">if</span>(seg[v]) <span class="keyword">continue</span>;</span><br><span class="line">		seg[v]=++tot;</span><br><span class="line">		rev[tot]=v;</span><br><span class="line">		top[v]=v;</span><br><span class="line">		<span class="built_in">dfs2</span>(v,u);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Line</span> &#123;</span><br><span class="line">	ll k,b,id;</span><br><span class="line">	<span class="built_in">Line</span>() &#123;&#125;</span><br><span class="line">	<span class="built_in">Line</span>(ll a,ll bb,ll i) &#123;</span><br><span class="line">		k=a,b=bb,id=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">ll <span class="title">val</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> k*dep[rev[x]]+b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Line a[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function">il <span class="type">void</span> <span class="title">push_up</span><span class="params">(ll now)</span> </span>&#123;</span><br><span class="line">	tr[now].minn=<span class="built_in">min</span>(tr[<span class="built_in">lc</span>(now)].minn,tr[<span class="built_in">rc</span>(now)].minn);</span><br><span class="line">	tr[now].minn=<span class="built_in">min</span>(tr[now].minn,<span class="built_in">min</span>(a[tr[now].maxid].<span class="built_in">val</span>(tr[now].l),a[tr[now].maxid].<span class="built_in">val</span>(tr[now].r)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="type">void</span> <span class="title">build</span><span class="params">(ll now,ll l,ll r)</span> </span>&#123;</span><br><span class="line">	tr[now].l=l,tr[now].r=r;</span><br><span class="line">	<span class="keyword">if</span>(l==r) &#123;</span><br><span class="line">		tr[now].maxid=<span class="number">0</span>,tr[now].minn=<span class="number">123456789123456789ll</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ll mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">build</span>(<span class="built_in">lc</span>(now),l,mid);</span><br><span class="line">	<span class="built_in">build</span>(<span class="built_in">rc</span>(now),mid+<span class="number">1</span>,r);</span><br><span class="line">	<span class="built_in">push_up</span>(now);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="type">void</span> <span class="title">cover</span><span class="params">(ll l,ll r,ll now,ll id)</span> </span>&#123;</span><br><span class="line">    ll mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(a[id].<span class="built_in">val</span>(mid)&lt;a[tr[now].maxid].<span class="built_in">val</span>(mid)) <span class="built_in">swap</span>(id,tr[now].maxid);</span><br><span class="line">    <span class="keyword">if</span>(l==r) &#123;</span><br><span class="line">    	tr[now].minn=<span class="built_in">min</span>(tr[now].minn,<span class="built_in">min</span>(a[tr[now].maxid].<span class="built_in">val</span>(l),a[tr[now].maxid].<span class="built_in">val</span>(r)));</span><br><span class="line">    	<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">if</span>(a[id].<span class="built_in">val</span>(l)&lt;a[tr[now].maxid].<span class="built_in">val</span>(l)) <span class="built_in">cover</span>(l,mid,<span class="built_in">lc</span>(now),id);</span><br><span class="line">    <span class="keyword">if</span>(a[id].<span class="built_in">val</span>(r)&lt;a[tr[now].maxid].<span class="built_in">val</span>(r)) <span class="built_in">cover</span>(mid+<span class="number">1</span>,r,<span class="built_in">rc</span>(now),id);</span><br><span class="line">    <span class="built_in">push_up</span>(now);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="type">void</span> <span class="title">modify</span><span class="params">(ll nl,ll nr,ll l,ll r,ll now,ll id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;nl||nr&lt;l) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(nl&lt;=l&amp;&amp;r&lt;=nr) &#123;</span><br><span class="line">        <span class="built_in">cover</span>(l,r,now,id);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">modify</span>(nl,nr,l,mid,<span class="built_in">lc</span>(now),id);</span><br><span class="line">	<span class="built_in">modify</span>(nl,nr,mid+<span class="number">1</span>,r,<span class="built_in">rc</span>(now),id);</span><br><span class="line">	<span class="built_in">push_up</span>(now);</span><br><span class="line">    <span class="keyword">return</span>;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il ll <span class="title">query</span><span class="params">(ll qx,ll qy,ll l,ll r,ll now)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(qx&lt;=l&amp;&amp;r&lt;=qy) <span class="keyword">return</span> tr[now].minn;</span><br><span class="line">	<span class="keyword">if</span>(qy&lt;l||r&lt;qx) <span class="keyword">return</span> INF;</span><br><span class="line">	ll ans=<span class="built_in">min</span>(a[tr[now].maxid].<span class="built_in">val</span>(<span class="built_in">max</span>(qx,l)),a[tr[now].maxid].<span class="built_in">val</span>(<span class="built_in">min</span>(qy,r))),mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">min</span>(ans,<span class="built_in">min</span>(<span class="built_in">query</span>(qx,qy,l,mid,<span class="built_in">lc</span>(now)),<span class="built_in">query</span>(qx,qy,mid+<span class="number">1</span>,r,<span class="built_in">rc</span>(now))));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il ll <span class="title">LCA</span><span class="params">(ll x,ll y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(top[x]!=top[y]) &#123;</span><br><span class="line">		<span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">		x=fa[top[x]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(dep[x]&gt;dep[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="type">void</span> <span class="title">add</span><span class="params">(ll x,ll y,ll id)</span> </span>&#123;</span><br><span class="line">	ll fx=top[x],fy=top[y];</span><br><span class="line">	<span class="keyword">while</span>(fx!=fy) &#123;</span><br><span class="line">		<span class="keyword">if</span>(dep[fx]&lt;dep[fy]) <span class="built_in">swap</span>(x,y),<span class="built_in">swap</span>(fx,fy);</span><br><span class="line">		<span class="built_in">modify</span>(seg[fx],seg[x],<span class="number">1</span>,n,<span class="number">1</span>,id);</span><br><span class="line">		x=fa[fx];</span><br><span class="line">		fx=top[x];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(dep[x]&gt;dep[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">	<span class="built_in">modify</span>(seg[x],seg[y],<span class="number">1</span>,n,<span class="number">1</span>,id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il ll <span class="title">ask</span><span class="params">(ll x,ll y)</span> </span>&#123;</span><br><span class="line">	ll ans=INF,fx=top[x],fy=top[y];</span><br><span class="line">	<span class="keyword">while</span>(fx!=fy) &#123;</span><br><span class="line">		<span class="keyword">if</span>(dep[fx]&lt;dep[fy]) <span class="built_in">swap</span>(x,y),<span class="built_in">swap</span>(fx,fy);</span><br><span class="line">		ans=<span class="built_in">min</span>(ans,<span class="built_in">query</span>(seg[fx],seg[x],<span class="number">1</span>,n,<span class="number">1</span>));</span><br><span class="line">		x=fa[fx],fx=top[x];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(dep[x]&gt;dep[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">	ans=<span class="built_in">min</span>(ans,<span class="built_in">query</span>(seg[x],seg[y],<span class="number">1</span>,n,<span class="number">1</span>));</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	a[<span class="number">0</span>].b=<span class="number">123456789123456789ll</span>,a[<span class="number">0</span>].k=<span class="number">0</span>;</span><br><span class="line">	n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">		ll u=<span class="built_in">read</span>(),v=<span class="built_in">read</span>(),w=<span class="built_in">read</span>();</span><br><span class="line">		<span class="built_in">add_edge</span>(u,v,w);</span><br><span class="line">		<span class="built_in">add_edge</span>(v,u,w);</span><br><span class="line">	&#125;</span><br><span class="line">	tot=<span class="number">1</span>;</span><br><span class="line">	seg[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	rev[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	top[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">	tot=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line">		ll opt=<span class="built_in">read</span>(),s=<span class="built_in">read</span>(),t=<span class="built_in">read</span>();</span><br><span class="line">		<span class="keyword">if</span>(opt==<span class="number">1</span>) &#123;</span><br><span class="line">			ll AAA=<span class="built_in">read</span>(),BBB=<span class="built_in">read</span>();</span><br><span class="line">			ll lca=<span class="built_in">LCA</span>(s,t);</span><br><span class="line">			a[++tot]=<span class="built_in">Line</span>(-AAA,AAA*dep[s]+BBB,tot);</span><br><span class="line">			<span class="built_in">add</span>(s,lca,tot);</span><br><span class="line">			a[++tot]=<span class="built_in">Line</span>(AAA,dep[s]*AAA<span class="number">-2</span>*dep[lca]*AAA+BBB,tot);</span><br><span class="line">			<span class="built_in">add</span>(lca,t,tot);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">ask</span>(s,t));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//for(int i=1;i&lt;=n;i++) printf(&quot;%lld &quot;,query(seg[i],seg[i],1,n,1));</span></span><br><span class="line">		<span class="comment">//putchar(&#x27;\n&#x27;);</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN-diy">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/26/%E3%80%90%E9%B2%9C%E8%8A%B1%E3%80%91%E5%94%94%E5%99%97%E5%99%97%E5%99%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Qinshihuang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qinshihuang's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/26/%E3%80%90%E9%B2%9C%E8%8A%B1%E3%80%91%E5%94%94%E5%99%97%E5%99%97%E5%99%97/" class="post-title-link" itemprop="url">【鲜花】唔噗噗噗</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-26 21:35:04" itemprop="dateCreated datePublished" datetime="2024-04-26T21:35:04+08:00">2024-04-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-09 21:46:06" itemprop="dateModified" datetime="2024-05-09T21:46:06+08:00">2024-05-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="雕像爆炸的充要条件是“唔噗噗噗”。"><a href="#雕像爆炸的充要条件是“唔噗噗噗”。" class="headerlink" title="雕像爆炸的充要条件是“唔噗噗噗”。"></a>雕像爆炸的充要条件是“唔噗噗噗”。</h1><p>这时候我们就称 “雕像爆炸” 可以<strong>推出</strong> “唔噗噗噗”，同时 “唔噗噗噗” <strong>也</strong>可以推出 “雕像爆炸”。这记作：</p>
<script type="math/tex; mode=display">
\text{“雕像爆炸”}\Leftrightarrow\text{“唔噗噗噗”}</script><p>和符号 $\Leftrightarrow$ 被迫在一起的两个可怜的小东西有什么共同特征呢？我们一起来看看吧。</p>
<h2 id="从左到右"><a href="#从左到右" class="headerlink" title="从左到右"></a>从左到右</h2><blockquote>
<p>给定一个周长为 $L$ 的圆，从一个点出发，有 $n$ 个黑白熊雕像，编号为 $1$ 到 $n$，第 $i$ 个雕像在顺<br>时针 $X_i$ 米处，如果你没有在 $T_i$ 秒内收集到这个黑白熊雕像，那么这个雕像就会发出“唔噗噗噗”<br>的声音然后爆炸。</p>
</blockquote>
<p>想读懂这句话是什么意思，关键在于要读懂这句话。</p>
<p>首先我们来看第一句，“给定一个周长为 $L$ 的圆。”很酷啊！我们大家都知道圆周长公式为</p>
<script type="math/tex; mode=display">
L=2\pi r</script><p>同时，我们可以在下面的一句话中找到一些特殊而奇妙、神奇又美好、可爱又萌萌的性质：</p>
<blockquote>
<p>第一行两个<strong>整数</strong> $n,L$ 代表雕像数和圆的周长。</p>
</blockquote>
<p>太对了！这说明 $L$ 是一个地地道道的整数，也就是说 $L\in\mathbf{Z}$。其实我们还可以发现这里的 $L$ 显然是一个正整数。太对了！一个更紧确的界就是显而易见的：$L\in\mathbf{N}^+$。</p>
<p>同时，我们还注意到 $\pi$ 是一个著名的无理数，所以我们可以惊奇地发现：$r$ 不是一个有理数！</p>
<p>这句话的另一个表达方式是：$r\in \mathbf{R}\setminus\mathbf Q$。</p>
<p>还有一个表达方式：$r$ 不能被表达为两个互质整数 $p,q$ 的比值。</p>
<p>$\Huge\text{太对了！}$</p>
<p>中间那些部分没啥用，我们就先跳过了。</p>
<hr>
<h1 id="广告之后马上回来！"><a href="#广告之后马上回来！" class="headerlink" title="广告之后马上回来！"></a>广告之后马上回来！</h1><p><strong>你好，我是广告。</strong></p>
<p><strong>你好，我是广告。</strong></p>
<p><strong>你好，我是广告。</strong></p>
<p><strong>你好，我是广告。</strong></p>
<p><strong>你好，我是广告。</strong></p>
<p><strong>你好，我是广告。</strong></p>
<p><strong>你好，我是广告。</strong></p>
<p><strong>你好，我是广告。</strong></p>
<p><strong>你好，我是广告。</strong></p>
<p><strong>你好，我是广告。</strong></p>
<p><strong>你好，我是广告。</strong></p>
<p><strong>你好，我是广告。</strong></p>
<p><strong>你好，我是广告。</strong></p>
<p><strong>你好，我是广告。</strong></p>
<p><strong>你好，我是广告。</strong></p>
<hr>
<p>我们接着品析上面的这段话。</p>
<p>大家看，“你好”这个词象征着欢迎，而广告这个词则是表达了——</p>
<p><del>对不起看错行了</del></p>
<p>关键的部分来了！</p>
<blockquote>
<p>如果你没有在 $T_i$ 秒内收集到这个黑白熊雕像，那么这个雕像就会发出“唔噗噗噗”的声音然后爆炸。</p>
</blockquote>
<p>啊，我们看到我们想要的东西了。</p>
<p>“唔噗噗噗”是一个地地道道的拟声词，它的发音为：</p>
<script type="math/tex; mode=display">
\text{wu}\!\sim\sim\quad \text{pupupu}\!\sim\sim</script><p>“黑白熊”也是一个关键，需要理解。想到黑白熊，我们立刻想起来一个非常有名以至于妇孺皆知的动物：<strong>熊猫</strong>。这就不难发现为什么要建造“黑白熊雕像”了！敬仰熊猫，为它立雕像，这不是人间大义、值得歌颂千古的伟大善事！来，我们肃立一分钟，为我们可爱的大熊猫敬礼！</p>
<p>诶，那雕像为什么会爆炸呢？</p>
<p>毁坏文物雕像，会遭到判刑；毁坏大熊猫雕像，却是不尊重国家的行为。再结合一个我们忽略的重要信息：</p>
<blockquote>
<p>现在 JOI 君在这个点……</p>
</blockquote>
<p>JOI，即日本国赛。</p>
<p>小日子的阴谋浮上了水面！</p>
<p>结合“唔噗噗噗”这个非常难崩又难以理解的词语，不难想到小日子们想用这样可爱的外表来进行一系列阴谋活动。这正是他们能干出来的事！</p>
<hr>
<p>这样我们就得到了结论：可爱的黑白熊猫雕像爆炸是一场早有预谋的攻击，其主谋为小日子国度，妄图使用最新研发的代号 $\text{ID-wppp}$ 炸弹炸毁这些雕像。</p>
<p>这样我们证明了一件事：“唔噗噗噗”是可以推出雕像爆炸的，即</p>
<script type="math/tex; mode=display">
\text{“唔噗噗噗”}\Rightarrow\text{“雕像爆炸”}</script><h2 id="从右到左"><a href="#从右到左" class="headerlink" title="从右到左"></a>从右到左</h2><p>雕像爆炸怎么能推出“唔噗噗噗”呢？</p>
<p>我们利用反证法。</p>
<p>首先我们证明一个引理：<strong>计算等差数列的和的算法太快了，不够慢。</strong></p>
<p>大家知道计算等差数列的和的公式吗？我们记项数为 $n$，首项与末项分别为 $a_1,a_n$，那么其和为</p>
<script type="math/tex; mode=display">
S=\dfrac{n(a_1+a_n)}{2}</script><p>为了看出我们是怎么<strong>劣化</strong>这个算法的，不妨设 $a_i=i$。</p>
<p>我们来推一个式子：</p>
<script type="math/tex; mode=display">
\begin{aligned}\sum_{i=1}^ni&=\sum_{i=1}^n\sum_{d|i}\varphi(d)\\&=\sum_{d=1}^n\varphi(d)\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}1\\&=\sum_{i=1}^n\left\lfloor\dfrac{n}{i}\right\rfloor\varphi(i)\end{aligned}</script><p>我们可以预处理出 $\varphi(n)$，利用数论分块即可达到 $O(n)$ 预处理、$O(\sqrt n)$ 计算的复杂度。</p>
<p>能不能<strong>再慢点呢</strong>？可以！</p>
<p>我们预处理出 $1\sim O(n^{\frac23})$ 内的 $\varphi$ 函数值，然后使用<strong>杜教筛</strong>来计算出 $\varphi$ 函数的前缀值、进而求出它的区间和。</p>
<p>这样的时间复杂度是什么呢？一个 naive 的上界显然是 $O(n^\frac76)$ 的，但是这并不紧却，我们来看看究竟是什么。</p>
<p>我们可以认为，整个计算过程分为 $3$ 部分：</p>
<ol>
<li>$1\sim\sqrt{n}$，此时数论分块的块长为 $1$，每次调用杜教筛的时间复杂度为 $O(1)$（预处理值域内），这一部分的时间复杂度为 $O(\sqrt n)$。</li>
<li>$\sqrt n\sim n^\frac23$，此时数论分块的块长不再是 $1$，但是杜教筛的时间复杂度仍然是 $O(1)$，杜教筛调用的次数是 $O(\sqrt n-\sqrt[3]n)$ 的，因此这部分的时间复杂度是 $O(\sqrt n)$。</li>
<li>$n^\frac23\sim n$，这部分杜教筛的耗时不再是 $O(1)$ 而是 $O(n^\frac23)$，而块数为 $O(\sqrt[3]n)$，因此此时间复杂度为 $O(n)$。</li>
</ol>
<p>综上，我们得到了这个算法的时间复杂度是线性时间查询、$O(n^\frac23)$ 时间预处理。</p>
<hr>
<p>回过头来，我们证明这个引理有什么用呢？</p>
<p>我们仔细审视“唔噗噗噗”一词。第一个字“唔”可以被看做一个等差数列的首项，而后面的“噗”象征着对每一项增加 $1$。总而言之，“唔噗噗噗”可以被看做数列</p>
<script type="math/tex; mode=display">a=\{1,2,3,\cdots,n\}</script><p>我们捡雕像，可以看做对这个数列求和，而经过上面的讨论，我们需要的时间是 $O(n)$ 的，<strong>十分巨大</strong>，以至于会让雕像爆炸。雕像爆炸起源于唔噗噗噗，也结束于唔噗噗噗。</p>
<p>这样我们证明了一件事：“雕像爆炸”是可以推出唔噗噗噗的，即</p>
<script type="math/tex; mode=display">
\text{“雕像爆炸”}\Rightarrow\text{“唔噗噗噗”}</script><hr>
<p>我们回顾一下我们的探索过程。</p>
<p>证明部分生动具体地应用了“若 $A\subseteq B$，而 $B\subseteq A$，则 $A=B$”的证明思路。这为我们带来了一个警示：任何命题都有其背后的故事，任何命题也都有其背后的逻辑。</p>
<p>在证明过程中，我们还介绍了一种由 @<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/user/536743">秦屎皇</a> 口胡的 $O(n^\frac23)$ 预处理、$O(n)$ 解决等差数列求和问题的算法，利用了数论算法中的“欧拉函数 $\varphi(n)$”以及“杜教筛”等高级算法，以<strong>劣化</strong>原有的算法。</p>
<p>好了，今天的分享就到这里，我是 @<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/user/536743">秦屎皇</a>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN-diy">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/26/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96dp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Qinshihuang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qinshihuang's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/26/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96dp/" class="post-title-link" itemprop="url">斜率优化dp</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-26 21:32:42" itemprop="dateCreated datePublished" datetime="2024-04-26T21:32:42+08:00">2024-04-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-09 21:47:00" itemprop="dateModified" datetime="2024-05-09T21:47:00+08:00">2024-05-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="斜率优化"><a href="#斜率优化" class="headerlink" title="斜率优化"></a>斜率优化</h1><p>斜率优化，一种优化 1D/1D 转移 dp 的方式，即将转移方程化为一次函数 $y=kx+b$ 的形式，再利用建模转化，将转移变成在某些数据结构上，比如单调队列、单调栈、李超树的操作，以此来优化转移时间复杂度。</p>
<p>一般来说（我感觉）斜率优化的转移方程里常常见到 $s_is_j$ 的形式。</p>
<h2 id="例子：AT-dp-z-Frog-3"><a href="#例子：AT-dp-z-Frog-3" class="headerlink" title="例子：AT_dp_z Frog 3"></a>例子：AT_dp_z Frog 3</h2><p>容易写出 dp 方程</p>
<script type="math/tex; mode=display">
dp_i=\min\{dp_j+(s_i-s_j)^2+c\}</script><p>化简得到</p>
<script type="math/tex; mode=display">
dp_i-s_i^2-c=dp_j+s_j^2-2s_i\cdot s_j</script><p>发现 $s_i$ 单调递增，即作为斜率的 $2s_i$ 单调递增，利用单调队列维护凸包可以做到 $O(n)$。</p>
<h2 id="例子：P2365-amp-P5785-任务安排两件套"><a href="#例子：P2365-amp-P5785-任务安排两件套" class="headerlink" title="例子：P2365&amp;P5785 任务安排两件套"></a>例子：P2365&amp;P5785 任务安排两件套</h2><p>P2365 可以用暴力过去。</p>
<p>首先考虑到时间花费中的 $s$ 依赖于前面的决策段数，这不利于进行转移（暴力就无所谓了 XD），因此考虑把划分的时间额外开销进行贡献转化。考虑如果在这里划分，后面的所有部分都会有贡献，其贡献是 $s\cdot\sum\limits_{j=i}^nf_j$。</p>
<p>然后可以写出转移方程了。这里 $t_i&gt;0$，因此前缀和是单增的，因此可以使用单调队列 $O(n)$。</p>
<p>然而在 P5785 中，$|t_i|\le2^8$，这表明 $t_i$ 不保证是正的（<del>唐氏吗完成任务还倒贴时间了是吧</del>），此时斜率不保证单增（<del>但能得 60 分</del>），因此拿二分队列做就可以了，时间复杂度 $O(n\log n)$。</p>
<h2 id="更加劲爆的例子：P1721-国王饮水记"><a href="#更加劲爆的例子：P1721-国王饮水记" class="headerlink" title="更加劲爆的例子：P1721 国王饮水记"></a>更加劲爆的例子：P1721 国王饮水记</h2><p>更详细的介绍可见<a target="_blank" rel="noopener" href="https://max.book118.com/html/2019/1011/8075031075002054.shtm">这个课件</a>。</p>
<p><strong>Lemma 1</strong> 你发现如果一个水位 $h_i&lt;h_1$，那么这个水位一定不会造成任何贡献。直接删掉！</p>
<p><strong>Lemma 2</strong> 每个水缸最多会和 $1$ 连接一次。因为连接一次后他俩就一样高了，不会再造成贡献了。</p>
<p><strong>Lemma 3</strong> 每次联通的时候都会有 $1$。可以证明 <strong>Lemma 2</strong> 与 <strong>Lemma 3</strong> 是等价的。</p>
<p><strong>Lemma 4</strong> 当 $k\rightarrow\infty$ 时最优操作为将 $h_i$ 从小到大排序后依次向上一个一个取平均。</p>
<p>你发现一次操作可以被拆成若干次 $1$ 节点与单个节点的平衡，而有式子</p>
<script type="math/tex; mode=display">
\dfrac{h_1+h_2}{2}+h_3\ge\dfrac{h_1+h_3}{h_2}</script><p>此处 $h_1&lt;h_2&lt;h_3$。</p>
<p>于是对于任意两个节点，一定是水量小的与 $1$ 先连接，再让水量大的连接。</p>
<hr>
<p>非常自然地想到要对 $h$ 排序并去掉比 $h_1$ 小的元素。</p>
<p>有了这些性质可以敲出一个 $O(k3^n)$ 的状压 dp 来。</p>
<p>同时根据 <strong>Lemma 2,4</strong> 可以知道有效操作数量不会超过 $O(n)$，直接取 $\min$ 是对的。</p>
<blockquote>
<p>写一个取最大 $K$ 个的贪心。等等，为什么我的得分比 $45$ 高这么多？——《NOI2016 国王饮水记 讲课ppt》</p>
</blockquote>
<hr>
<p>然后又有 $3$ 个重要的定理：</p>
<p><strong>Lemma 5</strong> 每次操作选择的城市的最小水量一定大于上一操作的最大水量。否则你交换两个逆序的城市按照 <strong>Lemma 4</strong> 会变得更优。</p>
<p><strong>Lemma 6</strong> 每次操作选择的一定是个区间。<del>可以找规律对吧</del>如果不是区间，那么把选择的最小水量城市换成任意一个断点都会变优。</p>
<p><strong>Lemma 7</strong> 每次操作选择的区间连续。否则把左边区间向右移一定更优。</p>
<hr>
<p>到这里转移变成区间了！</p>
<p>设 $dp_{i,j}$ 表示考虑到第 $i$ 个城市并且进行了 $j$ 次操作的最大水位，则有转移方程</p>
<script type="math/tex; mode=display">
dp_{i,j}=\max_{0\le k<i}\left\{\dfrac{dp_{k,j-1}+s_i-s_k}{i-k+1}\right\}</script><p>其中 $s_i$ 表示水量前缀和。</p>
<p>直接转移时间复杂度是 $O(n^2kp)$ 的。</p>
<p>你重新审视一下这个方程，设最优决策点为 $k$，给他变形得到</p>
<script type="math/tex; mode=display">
\begin{aligned}dp_{i,j}&=\dfrac{dp_{k,j-1}+s_i-s_k}{i-k+1}\\&=\dfrac{s_i-(s_k-dp_{k,j-1})}{i-(k-1)}\end{aligned}</script><p>虽然这不是斜率优化常见的式子形式 $y=kx+b$，但是这个却是<strong>斜率的表达式</strong></p>
<script type="math/tex; mode=display">
k=\dfrac{y(i)-y(j)}{x(i)-x(j)}</script><p>因此也可以斜率优化，其中凸包上的点为 $(k-1,s_k-dp_{k,j-1})$。</p>
<p>当前转移点就是过点 $(i,s_i)$ 的凸包上点的斜率最小值，可以用三分来求出，时间复杂度被优化到 $O(nkp\log n)$。</p>
<hr>
<p>但是这样只能过 $70$ 分，考虑继续优化。</p>
<p><strong>Lemma 8</strong> 决策点有单调性。</p>
<p>假设两个决策点为 $k&gt;l$ 且 $k$ 比 $l$ 优，按照定义有 $dp_{k,j-1}\ge dp_{l,j-1}$。然后你对不等式做一个变形</p>
<script type="math/tex; mode=display">
\begin{aligned}(k-l)(s_k-s_l+dp_{k,j-1})&\ge(i-l+1)h_k+(k-l)h_{i+1}\\&\ \ \ \ \ -(i-k-1)(dp_{k,j-1}-dp_{k-1,j-1})\\&\ge(i-l+1)[h_k-(dp_{k,j-1}-dp_{k-1,j-1})]\end{aligned}</script><p>得证。</p>
<hr>
<p>得到决策单调性之后利用单调队列可以少一个 $\log$。</p>
<p>还可以优化？</p>
<p>注意到水量高度互不相同，可以知道<strong>每一次操作的区间长度不会大于上一次的区间长度</strong>。感性的想就是越往后走高度越大，显然拿更少的位置来平分会更优。另一个奇妙的性质是：长度大于 $1$ 的决策区间很少，只有 $O(\log\frac{nk}{\Delta})$，其中 $\Delta=\min\{h_i-h_{i-1}\}$。</p>
<p>为什么我也不会了。</p>
<p>这样子就不用 dp $k$ 层了，只需要 dp 这么多层就可以了。</p>
<p>时间复杂度是 $O(np\log nh)$。</p>
<p>但是居然还有 $O(n(\log^3nh+p))$ 的做法在 ppt 里？太奆了不会。</p>
<p>给个高精小数 Decimal 类还是很善良的！</p>
<h1 id="一些很蠢的事情"><a href="#一些很蠢的事情" class="headerlink" title="一些很蠢的事情"></a>一些很蠢的事情</h1><h2 id="警钟爆破队长"><a href="#警钟爆破队长" class="headerlink" title="警钟爆破队长"></a>警钟爆破队长</h2><p>求斜率的常见计算方式是</p>
<script type="math/tex; mode=display">
k=\dfrac{y(i)-y(j)}{x(i)-x(j)}</script><p>但是这样是要用实数的，爆精度就似了。考虑移项之后用乘法保住精度。</p>
<p>但是很重要的一个细节是 $x(i)-x(j)$ 不要写反，一定是大减小，不然移项的时候会导致不等式方向变化就似了。</p>
<h2 id="警钟爆破队员-1-号"><a href="#警钟爆破队员-1-号" class="headerlink" title="警钟爆破队员 1 号"></a>警钟爆破队员 1 号</h2><p>@P2120。</p>
<p>你发现这个题很简单对吧！</p>
<p>考虑设 $dp_i$ 表示在第 $i$ 个工厂上建造仓库的最小开支。</p>
<p>但是你发现转移的时候 $val(l,r)$ 不易计算，需要展开一下。</p>
<p>具体的：</p>
<script type="math/tex; mode=display">
\begin{aligned}\sum_{i=l}^rp_i\cdot dis(i,r)&=\sum_{i=l}^rp_i(x_r-x_i)\\&=x_r\sum_{i=l}^rp_i-\sum_{i=l}^rp_ix_i\end{aligned}</script><p>我们记 $s1_i=\sum\limits_{j=1}^ip_j$，$s2_i=\sum\limits_{j=1}^ip_jx_j$，那么上式化简为</p>
<script type="math/tex; mode=display">
x_r(s1_r-s1_{l-1})-(s2_r-s2_{l-1})</script><p>你写出 dp 方程：</p>
<script type="math/tex; mode=display">
dp_i=\min_{0\le j<i}\{dp_j+val(j-1,i)+c_i\}</script><p>设 $j$ 是转移最优决策点则有</p>
<script type="math/tex; mode=display">
dp_i=dp_j+x_i(s1_i-s1_j)-(s2_i-s2_j)+c_i</script><p>化简得</p>
<script type="math/tex; mode=display">
dp_i-x_is1_i-s2_i-c_i=dp_j+s2_j-x_i\cdot s1_j</script><p>这就是斜率优化的板子了，注意到 $x_i$ 单调递增于是直接 $O(n)$。</p>
<p>于是你<a href="//" title="真的，我用了17分钟推完+写完了">迅速地敲完了</a>这个题，测试样例，通过了！</p>
<p>然后你提交，诶，怎么 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/record/150583068">Unaccepted 100分</a>啊？你很生气。</p>
<p>你百思不得其解，打开讨论区，全是诸如<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/discuss/783542">被hack力，求调（悲</a>此类的东西。你随便打开了一个，看到这样一句话：</p>
<blockquote>
<p>最后可能会有一长条 $p_i=0$ 的可（毒）爱（瘤）工厂，最后答案是尾巴上所有 $p_i=0$ 的工厂的 dp 值取 $\min$。</p>
</blockquote>
<p>你怀着愤恨的心情去骂 ZJOI2007 的出题人没有良心。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN-diy">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/26/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Qinshihuang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qinshihuang's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/26/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">后缀数组学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-26 21:29:22" itemprop="dateCreated datePublished" datetime="2024-04-26T21:29:22+08:00">2024-04-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-09 21:46:30" itemprop="dateModified" datetime="2024-05-09T21:46:30+08:00">2024-05-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="SA-数组"><a href="#SA-数组" class="headerlink" title="SA 数组"></a>SA 数组</h1><p>后缀数组维护了字符串每个后缀的大小关系。利用这个数组可以维护很多厉害的信息。</p>
<p>但是首先要求出 $sa,rk$ 数组。</p>
<p>$sa_i$ 表示 $s[i\dots n]$ 这个后缀的大小排名，而 $rk_i$ 代表排名为 $i$ 的开头位置。显然有 $sa_{rk_i}=rk_{sa_i}=i$。</p>
<p>首先一个暴力算法是显然的：将所有后缀字符串排序。时间复杂度为 $O(n^2\log n)$。这个速度肯定不能被接受，需要优化，<strong>可以使用倍增算法来优化。</strong></p>
<p>首先对长度为 $1$ 的子串排序，这个东西很简单，于是得到了所有长度为 $1$ 的子串大小关系 $p_i$。</p>
<p>接下来再对长度为 $2$ 的子串排序，方法是将相邻的两个长度 $1$ 子串合并起来成为 $c_i=(p_i,p_{i+1})$。接下来对 $c_i$ 进行双关键字排序即可得到长度为 $2$ 的子串大小关系。</p>
<p>为什么是对的呢？其实很简单，先比较字符串的前半段，因为已经得到了大小关系所以可以直接比较；如果前半段相同就比较后半段。</p>
<p>接下来如法炮制，得到 $4,8,16,\dots,2^w$ 直到长度比 $n$ 大。这样就得到了所有后缀的大小关系。这样时间复杂度是 $O(n\log^2n)$。</p>
<p>一个发现是上面的做法中使用了 sort 进行排序，是 $O(n\log n)$ 的，再乘上倍增的复杂度就是 $O(n\log^2n)$ 的。</p>
<p>一个简单的思路就是换一个排序，比如基数排序或者计数排序。这样的复杂度就是 $O(n\log n)$ 的了。</p>
<p>此时根据上面 $sa,rk$ 的关系可以求出 $rk$ 数组。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">il <span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> m=<span class="number">127</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) x[i]=s[i],cnt[x[i]]++;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=m;i++) cnt[i]+=cnt[i<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--) sa[cnt[x[i]]--]=i;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> w=<span class="number">1</span>;w&lt;=n;w&lt;&lt;=<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="type">int</span> tot=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=n-w+<span class="number">1</span>;i&lt;=n;i++) y[++tot]=i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(sa[i]&gt;w) y[++tot]=sa[i]-w;</span><br><span class="line"><span class="comment">//第二关键字可以不进行基数排序。只需要在排序前按照排序后的顺序放进去就可以了。</span></span><br><span class="line"><span class="comment">//基数排序是稳定的排序算法。</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) cnt[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cnt[x[i]]++;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=m;i++) cnt[i]+=cnt[i<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--) sa[cnt[x[y[i]]]--]=y[i],y[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">swap</span>(x,y);tot=x[sa[<span class="number">1</span>]]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(y[sa[i]]==y[sa[i<span class="number">-1</span>]]&amp;&amp;y[sa[i]+w]==y[sa[i<span class="number">-1</span>]+w]) x[sa[i]]=tot;</span><br><span class="line">			<span class="keyword">else</span> x[sa[i]]=++tot;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(tot==n) <span class="keyword">break</span>;</span><br><span class="line">		m=tot;		<span class="comment">//优化值域、提前退出来减小常数</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) rk[sa[i]]=i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="height-数组"><a href="#height-数组" class="headerlink" title="height 数组"></a>height 数组</h1><p><del>为啥要叫 height 捏</del></p>
<p>$\text{height}$ 数组记录了排序后相邻后缀的最长公共前缀，lcp 的长度。也就是说 $\text{height}_i=\operatorname{LCP}(sa_i,sa_{i-1})$。</p>
<p>如何求 $\text{height}$ 数组？一个显然的思路是暴力匹配，但是这东西是 $O(n^2)$ 的，太慢了。</p>
<p>而 $O(n)$ 求 $\text{height}$ 需要一个引理：</p>
<script type="math/tex; mode=display">
\text{height}_{rk_i}\ge\text{height}_{rk_{i-1}}-1</script><blockquote>
<p>证明：当 $\text{height}_{rk_{i-1}}\le1$ 时显然成立。</p>
<p>如果 $\text{height}_{rk_{i-1}}&gt;1$，则根据定义有 $\operatorname{LCP}(sa_{rk_{i-1}},sa_{rk_{i-1}-1})&gt;1$，即 $\operatorname{LCP}(i-1,sa_{rk_{i-1}-1})&gt;1$。</p>
<p>那么不妨设这个公共前缀为 $cA$，那么可以设后缀 $i-1=cAB$，$sa_{rk_{i-1}-1}=cAD$。这样 $i=AB$，并且有一个后缀 $sa_{rk_{i-1}-1}+1=AD$。</p>
<p>根据后缀数组的定义可以发现 $sa_{rk_i-1}$ 只比 $i$ 靠前一个，并且 $AD&lt;AB$，所以 $AD\le sa_{rk_i-1}&lt;AB$。</p>
<p>所以</p>
<script type="math/tex; mode=display">
\operatorname{LCP}(i,sa_{rk_i-1})=A\ge cA-1=\operatorname{LCP}(i-1,sa_{rk_{i-1}-1})-1</script><p>可以得到 $\text{height}_{rk_i}\ge\text{height}_{rk_{i-1}}-1$。</p>
</blockquote>
<p>得到这个引理之后就可以利用它求解 $\text{height}$ 了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,k=<span class="number">0</span>;i&lt;=n;i++) &#123;</span><br><span class="line">	<span class="keyword">if</span>(rk[i]==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">	<span class="keyword">if</span>(k) k--;</span><br><span class="line">	<span class="keyword">while</span>(s[i+k]==s[sa[rk[i]<span class="number">-1</span>]+k]) k++;</span><br><span class="line">	height[rk[i]]=k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现 $k$ 减少 $n$ 次，而 $k$ 还不会超过 $n$，因此这个算法时间复杂度为 $O(n)$。</p>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="Milk-Patterns-G：出现至少-k-次的子串的最大长度"><a href="#Milk-Patterns-G：出现至少-k-次的子串的最大长度" class="headerlink" title="Milk Patterns G：出现至少 $k$ 次的子串的最大长度"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2852">Milk Patterns G</a>：出现至少 $k$ 次的子串的最大长度</h2><p>给定一个数组，求一个最长的子数组使得它在大数组中出现了至少 $k$ 次。</p>
<p>事实上，如果一个子数组作为整个数组的 $k$ 后缀的公共前缀，那么它就出现了至少 $k$ 次，而可以将数组后缀排序后求出 $\text{height}$ 数组。</p>
<p>显然，离得更近的后缀的 lcp 长度会更大，所以最优的选择是选取 $\text{height}$ 数组的长度 $k-1$ 的区间的最小值。</p>
<p>于是使用单调队列取其最大值即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> il inline</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 20005</span></span><br><span class="line"><span class="function">il ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>) &#123;f=<span class="number">-1</span>;&#125; c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>);c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,k,m=<span class="number">1000005</span>;</span><br><span class="line"><span class="type">int</span> a[N],cnt[<span class="number">1000005</span>],x[N],y[N],sa[N],rk[N],height[N];</span><br><span class="line"><span class="type">int</span> que[N],head,tail;</span><br><span class="line"><span class="function">il <span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) x[i]=a[i],cnt[x[i]]++;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=m;i++) cnt[i]+=cnt[i<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--) sa[cnt[x[i]]--]=i;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> w=<span class="number">1</span>;w&lt;=n;w&lt;&lt;=<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="type">int</span> tot=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=n-w+<span class="number">1</span>;i&lt;=n;i++) y[++tot]=i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(sa[i]&gt;w) y[++tot]=sa[i]-w;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) cnt[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cnt[x[i]]++;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=m;i++) cnt[i]+=cnt[i<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--) sa[cnt[x[y[i]]]--]=y[i],y[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">swap</span>(x,y),tot=x[sa[<span class="number">1</span>]]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(y[sa[i]]==y[sa[i<span class="number">-1</span>]]&amp;&amp;y[sa[i]+w]==y[sa[i<span class="number">-1</span>]+w]) x[sa[i]]=tot;</span><br><span class="line">			<span class="keyword">else</span> x[sa[i]]=++tot;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(tot==n) <span class="keyword">return</span>;</span><br><span class="line">		m=tot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>(),k=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i]=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">solve</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) rk[sa[i]]=i;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,k=<span class="number">0</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(rk[i]==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(k) k--;</span><br><span class="line">		<span class="keyword">while</span>(a[i+k]==a[sa[rk[i]<span class="number">-1</span>]+k]) k++;</span><br><span class="line">		height[rk[i]]=k;</span><br><span class="line">	&#125;</span><br><span class="line">	head=tail=<span class="number">1</span>,que[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	ll ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">while</span>(head&lt;=tail&amp;&amp;i-que[head]&gt;=k<span class="number">-1</span>) head++;</span><br><span class="line">		<span class="keyword">while</span>(head&lt;=tail&amp;&amp;height[i]&lt;height[que[tail]]) tail--;</span><br><span class="line">		que[++tail]=i;</span><br><span class="line">		<span class="keyword">if</span>(i&gt;=k<span class="number">-1</span>&amp;&amp;head&lt;=tail) ans=<span class="built_in">max</span>(ans,<span class="number">1ll</span>*height[que[head]]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Best-Cow-Line-G：快速比较子串大小"><a href="#Best-Cow-Line-G：快速比较子串大小" class="headerlink" title="Best Cow Line G：快速比较子串大小"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2870">Best Cow Line G</a>：快速比较子串大小</h2><p>给出一个含有 $n$ 个字符的双端队列，每次可以从队首或者队尾出队，求可能的出队队列中字典序最小的一个。</p>
<p>首先可以发现如果队头队尾的字符不同，那么一定先出小的那个。</p>
<p>考虑如果队头队尾的字符相同是什么情况。显然出队时还是要按照“让更小的字符更快出队”的原则。可以发现如果剩余字符串正着读字典序要比反着读的要小，那么就出头；否则出尾。</p>
<p>至于怎么快速比较字符串的大小，可以对字符串的正序和倒序分别建立后缀数组和 $\text{height}$ 数组。对于两个字符串 $A,B$（不妨设 $|A|\le|B|$），设 $l=\operatorname{LCP}(A,B)$，可以发现如果 $l\ge|A|$，那么 $A$ 一定是 $B$ 的前缀，显然 $A$ 更小；否则就比较对应的后缀大小（因为比较的不同点一定在两个字符串内）。这样的比较时间复杂度是 $O(1)$ 的。</p>
<p>总时间复杂度就是 $O(n\log n)$。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> il inline</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1000005</span></span><br><span class="line"><span class="function">il ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>) &#123;f=<span class="number">-1</span>;&#125; c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>);c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m=<span class="number">127</span>;</span><br><span class="line"><span class="type">int</span> x[N],y[N],cnt[N],sa[N],rk[N],height[N];</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="function">il <span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) x[i]=s[i],cnt[x[i]]++;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=m;i++) cnt[i]+=cnt[i<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--) sa[cnt[x[i]]--]=i;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> w=<span class="number">1</span>;w&lt;=n;w&lt;&lt;=<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="type">int</span> tot=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=n-w+<span class="number">1</span>;i&lt;=n;i++) y[++tot]=i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(sa[i]&gt;w) y[++tot]=sa[i]-w;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) cnt[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cnt[x[i]]++;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=m;i++) cnt[i]+=cnt[i<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--) sa[cnt[x[y[i]]]--]=y[i],y[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">swap</span>(x,y);tot=x[sa[<span class="number">1</span>]]=<span class="number">1</span>; </span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(y[sa[i]]==y[sa[i<span class="number">-1</span>]]&amp;&amp;y[sa[i]+w]==y[sa[i<span class="number">-1</span>]+w]) x[sa[i]]=tot;</span><br><span class="line">			<span class="keyword">else</span> x[sa[i]]=++tot;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(tot==n) <span class="keyword">break</span>;</span><br><span class="line">		m=tot;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) rk[sa[i]]=i;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,k=<span class="number">0</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(rk[i]==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(k) k--;</span><br><span class="line">		<span class="keyword">while</span>(s[i+k]==s[sa[rk[i]<span class="number">-1</span>]+k]) k++;</span><br><span class="line">		height[rk[i]]=k;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> st[N][<span class="number">21</span>],Log[N];</span><br><span class="line"><span class="function">il <span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) st[i][<span class="number">0</span>]=height[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">20</span>;j++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i+(<span class="number">1</span>&lt;&lt;j)&lt;=n;i++) st[i][j]=<span class="built_in">min</span>(st[i][j<span class="number">-1</span>],st[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="type">int</span> <span class="title">RMQ</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> k=Log[r-l+<span class="number">1</span>]; </span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">min</span>(st[l][k],st[r-(<span class="number">1</span>&lt;&lt;k)][k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,&amp;s[i]);</span><br><span class="line">		s[<span class="number">2</span>*n-i+<span class="number">2</span>]=s[i];</span><br><span class="line">	&#125;</span><br><span class="line">	s[n+<span class="number">1</span>]=<span class="string">&#x27;#&#x27;</span>,n=<span class="number">2</span>*n+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) Log[i]=Log[i&gt;&gt;<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">solve</span>();</span><br><span class="line">	<span class="type">int</span> p=<span class="number">1</span>,q=n/<span class="number">2</span>,cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">build</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n/<span class="number">2</span>;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(s[p]!=s[q]) &#123;</span><br><span class="line">			<span class="keyword">if</span>(s[p]&lt;s[q]) <span class="built_in">putchar</span>(s[p++]);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">putchar</span>(s[q--]);</span><br><span class="line">			cnt++;</span><br><span class="line">			<span class="keyword">if</span>(cnt==<span class="number">80</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>),cnt=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//比较[p,q]与[q,p]大小关系。</span></span><br><span class="line">			<span class="type">int</span> pp=n-p+<span class="number">1</span>,qq=n-q+<span class="number">1</span>;</span><br><span class="line">			<span class="type">int</span> lcp=<span class="built_in">RMQ</span>(<span class="built_in">min</span>(rk[qq],rk[p]),<span class="built_in">max</span>(rk[qq],rk[p])),pd;</span><br><span class="line">			<span class="keyword">if</span>(lcp==q-p+<span class="number">1</span>) pd=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(rk[qq]&lt;rk[p]) pd=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> pd=<span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">if</span>(pd&gt;=<span class="number">0</span>) <span class="built_in">putchar</span>(s[q--]);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">putchar</span>(s[p++]);</span><br><span class="line">			cnt++;</span><br><span class="line">			<span class="keyword">if</span>(cnt==<span class="number">80</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>),cnt=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="优秀的拆分：连续的两个相同子串"><a href="#优秀的拆分：连续的两个相同子串" class="headerlink" title="优秀的拆分：连续的两个相同子串"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1117">优秀的拆分</a>：连续的两个相同子串</h2><p>对一个字符串的所有子串求 $\text{AABB}$ 拆分的个数。</p>
<p>首先转化一下，设 $f_i$ 为从字符串第 $i$ 位开始向前的“$AA$”类型字符串个数，$g_i$ 为向后的个数，那么答案就是</p>
<script type="math/tex; mode=display">
\sum_{i=1}^nf_ig_{i+1}</script><p>考虑枚举 $A$ 的长度为 $l$，并且设所有 $i$ 使得 $l|i$ 为关键点，那么一个合法的 $AA$ 一定能经过两个关键点。</p>
<p>比如说这种情况：</p>
<script type="math/tex; mode=display">
\begin{matrix}...i-1|\underbrace{i_1...........i_2-1}|i_2......\\\ \ l\end{matrix}</script><p>这上面有一个 $AA$ 能够匹配：</p>
<script type="math/tex; mode=display">
\begin{matrix}A\\\overbrace{...i_1-1|i_1......}\end{matrix}\begin{matrix}A\\\overbrace{...i_2-1|i_2......}\end{matrix}</script><p>那么可以发现，其 lcp 和 lcs 有这样的关系：</p>
<script type="math/tex; mode=display">
\begin{matrix}\underbrace{...i_1-1}|\\\text{lcs}\end{matrix}\begin{matrix}\underbrace{i_1......}\\\text{lcp}\end{matrix}\begin{matrix}\underbrace{...i_2-1}|\\\text{lcs}\end{matrix}\begin{matrix}\underbrace{i_2......}\\\text{lcp}\end{matrix}</script><p>可以发现，这一段的 lcp 必须等于下一段的 lcp，并且这一段的 lcs 必须等于上一段的 lcs。</p>
<p>不妨设这一段与下一段的 lcp 为 $\text{lcp}$，并且这一段与上一段的 lcs 为 $\text{lcs}$。那么显然 $\text{lcp}+\text{lcs}=l$ 时，有一组 $AA$ 匹配。事实上，如果 $\text{lcp}+\text{lcs}&lt;l$ 那么不存在合法的匹配，并且如果 $\text{lcp}+\text{lcs}\ge l$，那么就有 $t=\text{lcp}+\text{lcs}-l+1$ 组合法的匹配。</p>
<p>注意到这里 $AA$ 出现的位置是一段区间，可以使用差分来区间加。</p>
<p>就做完了，时间复杂度为 $O(n\log n)$。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> il inline</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 50005</span></span><br><span class="line"><span class="function">il ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>) &#123;f=<span class="number">-1</span>;&#125; c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>);c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,x[N],y[N],cnt[N],sa[<span class="number">2</span>][N],rk[<span class="number">2</span>][N],hei[<span class="number">2</span>][N];</span><br><span class="line"><span class="type">int</span> st[<span class="number">2</span>][N][<span class="number">17</span>],Log[N];</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="function">il <span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) x[i]=s[i],cnt[x[i]]++;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=m;i++) cnt[i]+=cnt[i<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--) sa[id][cnt[x[i]]--]=i;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> w=<span class="number">1</span>;w&lt;=n;w&lt;&lt;=<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="type">int</span> tot=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=n-w+<span class="number">1</span>;i&lt;=n;i++) y[++tot]=i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(sa[id][i]&gt;w) y[++tot]=sa[id][i]-w;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) cnt[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cnt[x[i]]++;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=m;i++) cnt[i]+=cnt[i<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--) sa[id][cnt[x[y[i]]]--]=y[i],y[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">swap</span>(x,y);tot=x[sa[id][<span class="number">1</span>]]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(y[sa[id][i]]==y[sa[id][i<span class="number">-1</span>]]&amp;&amp;y[sa[id][i]+w]==y[sa[id][i<span class="number">-1</span>]+w]) x[sa[id][i]]=tot;</span><br><span class="line">			<span class="keyword">else</span> x[sa[id][i]]=++tot;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(tot==n) <span class="keyword">break</span>;</span><br><span class="line">		m=tot;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) rk[id][sa[id][i]]=i;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,k=<span class="number">0</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(rk[id][i]==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(k) k--;</span><br><span class="line">		<span class="keyword">while</span>(s[i+k]==s[sa[id][rk[id][i]<span class="number">-1</span>]+k]) k++;</span><br><span class="line">		hei[id][rk[id][i]]=k;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="built_in">sizeof</span>(cnt));</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) x[i]=y[i]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) st[id][i][<span class="number">0</span>]=hei[id][i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">16</span>;j++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) st[id][i][j]=<span class="built_in">min</span>(st[id][i][j<span class="number">-1</span>],st[id][i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="type">int</span> <span class="title">getlcp</span><span class="params">(<span class="type">int</span> id,<span class="type">int</span> l,<span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> _l=l,_r=r;</span><br><span class="line">	l=<span class="built_in">min</span>(rk[id][_l],rk[id][_r])+<span class="number">1</span>,r=<span class="built_in">max</span>(rk[id][_l],rk[id][_r]);</span><br><span class="line">	<span class="type">int</span> k=Log[r-l+<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">min</span>(st[id][l][k],st[id][r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line">ll f[N],g[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(st,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(st));</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">	n=<span class="built_in">strlen</span>(s+<span class="number">1</span>),m=<span class="number">127</span>;</span><br><span class="line">	<span class="built_in">solve</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i*<span class="number">2</span>&lt;=n;i++) <span class="built_in">swap</span>(s[i],s[n-i+<span class="number">1</span>]);</span><br><span class="line">	m=<span class="number">127</span>;</span><br><span class="line">	<span class="built_in">solve</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i*<span class="number">2</span>&lt;=n;i++) <span class="built_in">swap</span>(s[i],s[n-i+<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>;l&lt;=n/<span class="number">2</span>;l++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=l;i+l&lt;=n;i+=l) &#123;</span><br><span class="line">			<span class="type">int</span> j=i+l;</span><br><span class="line">			<span class="type">int</span> lcp=<span class="built_in">min</span>(<span class="built_in">getlcp</span>(<span class="number">0</span>,i,j),l),lcs=<span class="built_in">min</span>(<span class="built_in">getlcp</span>(<span class="number">1</span>,n-i+<span class="number">2</span>,n-j+<span class="number">2</span>),l<span class="number">-1</span>);</span><br><span class="line">			<span class="keyword">if</span>(lcp+lcs&lt;l) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="type">int</span> t=lcp+lcs-l+<span class="number">1</span>;</span><br><span class="line">			g[i-lcs]++,g[i-lcs+t]--;</span><br><span class="line">			f[j+lcp-t]++,f[j+lcp]--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++) f[i]+=f[i<span class="number">-1</span>],g[i]+=g[i<span class="number">-1</span>];</span><br><span class="line">	ll ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ans+=f[i]*g[i+<span class="number">1</span>];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="type">void</span> <span class="title">clean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in">sizeof</span>(f));<span class="built_in">memset</span>(g,<span class="number">0</span>,<span class="built_in">sizeof</span>(g));</span><br><span class="line">	<span class="built_in">memset</span>(hei,<span class="number">0</span>,<span class="built_in">sizeof</span>(hei));<span class="built_in">memset</span>(rk,<span class="number">0</span>,<span class="built_in">sizeof</span>(rk));</span><br><span class="line">	<span class="built_in">memset</span>(sa,<span class="number">0</span>,<span class="built_in">sizeof</span>(sa));<span class="built_in">memset</span>(st,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(st));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">30000</span>;i++) Log[i]=Log[i&gt;&gt;<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> t=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">while</span>(t--) &#123;</span><br><span class="line">		<span class="built_in">mian</span>();<span class="built_in">clean</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="品酒大会：结合并查集"><a href="#品酒大会：结合并查集" class="headerlink" title="品酒大会：结合并查集"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2178">品酒大会</a>：结合并查集</h2><p>本质上是让你对每个 $r\in[0,n-1]$ 求长度为 $r$ 的相同子串对的个数以及两个相同子串开头权值乘积的最大值。</p>
<p>首先，因为如果两杯酒是 $r$ 相似可以推出它们是 $0,1,\dots,r-1$ 相似。所以只需求出 $\operatorname{LCP}(s,t)=r$ 的个数。</p>
<p>再次进行转化，对原字符串建立后缀数组与 $\text{height}$ 数组，因为 $\operatorname{LCP}(sa_i,sa_j)=\min\limits_{i&lt;k\le j}\{\text{height}_k\}$，因此又转化为 $\text{height}$ 数组区间最小值为 $r$ 的区间个数。</p>
<p>最后答案的求解需要使用<strong>并查集</strong>。将 $\text{height}$ 数组排序后按照倒序依次填写。假设现在要填写 $i$ 位置的 $\text{height}$，可以发现 $i$ 左边、右边已经填写部分的 $\text{height}$ 值均大于等于 $\text{height}_i$，因此区间左右端点在左右边的区间全部有贡献。此时用并查集维护已被填写的区间长度即可。</p>
<p>这是第一问，第二问只需维护已被填写的区间最大最小值即可。（因为 $a_i$ 可能小于 $0$）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> il inline</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 300005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mkpir make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="function">il ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>) &#123;f=<span class="number">-1</span>;&#125; c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>);c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,x[N],y[N],cnt[N];</span><br><span class="line"><span class="type">int</span> sa[N],rk[N],height[N];</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="function">il <span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> m=<span class="number">127</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) x[i]=s[i],cnt[x[i]]++;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=m;i++) cnt[i]+=cnt[i<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--) sa[cnt[x[i]]--]=i;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> w=<span class="number">1</span>;w&lt;=n;w&lt;&lt;=<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="type">int</span> tot=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=n-w+<span class="number">1</span>;i&lt;=n;i++) y[++tot]=i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(sa[i]&gt;w) y[++tot]=sa[i]-w;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) cnt[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cnt[x[i]]++;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=m;i++) cnt[i]+=cnt[i<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--) sa[cnt[x[y[i]]]--]=y[i],y[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">swap</span>(x,y);tot=x[sa[<span class="number">1</span>]]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(y[sa[i]]==y[sa[i<span class="number">-1</span>]]&amp;&amp;y[sa[i]+w]==y[sa[i<span class="number">-1</span>]+w]) x[sa[i]]=tot;</span><br><span class="line">			<span class="keyword">else</span> x[sa[i]]=++tot;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(tot==n) <span class="keyword">break</span>;</span><br><span class="line">		m=tot;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) rk[sa[i]]=i;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,k=<span class="number">0</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(rk[i]==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(k) k--;</span><br><span class="line">		<span class="keyword">while</span>(s[i+k]==s[sa[rk[i]<span class="number">-1</span>]+k]) k++;</span><br><span class="line">		height[rk[i]]=k;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; q[N];</span><br><span class="line"><span class="type">int</span> a[N],now,num=<span class="number">-1e18</span>;</span><br><span class="line"><span class="type">int</span> ans[<span class="number">2</span>][N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">	<span class="type">int</span> fa,siz,maxn,minn;</span><br><span class="line">&#125;;</span><br><span class="line">node e[N];</span><br><span class="line"><span class="function">il <span class="type">int</span> <span class="title">findf</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(x!=e[x].fa) x=e[x].fa=e[e[x].fa].fa;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="type">void</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> fx=<span class="built_in">findf</span>(x),fy=<span class="built_in">findf</span>(y);</span><br><span class="line">	now+=e[fx].siz*e[fy].siz,num=<span class="built_in">max</span>(num,<span class="built_in">max</span>(e[fx].maxn*e[fy].maxn,e[fx].minn*e[fy].minn));</span><br><span class="line">	e[fy].fa=fx,e[fx].siz+=e[fy].siz,e[fx].maxn=<span class="built_in">max</span>(e[fx].maxn,e[fy].maxn),e[fx].minn=<span class="built_in">min</span>(e[fx].minn,e[fy].minn);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i]=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">solve</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) e[i].fa=i,e[i].maxn=e[i].minn=a[sa[i]],e[i].siz=<span class="number">1</span>,q[height[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> p:q[i]) <span class="built_in">Union</span>(p,p<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">if</span>(now) ans[<span class="number">0</span>][i]=now,ans[<span class="number">1</span>][i]=num;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%lld %lld\n&quot;</span>,ans[<span class="number">0</span>][i],ans[<span class="number">1</span>][i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="找相同字符和差异：结合单调栈"><a href="#找相同字符和差异：结合单调栈" class="headerlink" title="找相同字符和差异：结合单调栈"></a><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3181">找相同字符</a>和<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4248">差异</a>：结合单调栈</h2><p>差异那道题更简单一些。</p>
<h3 id="差异"><a href="#差异" class="headerlink" title="差异"></a>差异</h3><p>给定一个字符串 $S$，其长度为 $n$，定义 $T_i$ 为从第 $i$ 个字符开始的后缀，你需要求出</p>
<script type="math/tex; mode=display">
\sum_{1\le i<j\le n}\operatorname{len}(T_i)+\operatorname{len}(T_j)-2\operatorname{lcp}(T_i,T_j)</script><p>的值。</p>
<p>首先这个式子分成两部分，第一部分就是求 $\text{len}$ 的和，这一部分其实就是</p>
<script type="math/tex; mode=display">
\begin{aligned}\sum_{1\le i<j\le n}(n-i+1)+(n-j+1)&=\sum_{i=1}^n\sum_{j=i+1}^n(n-i+1)(n-j+1)\\&=\dfrac{n(n-1)(n+1)}{2}\end{aligned}</script><p>所以只需要求出第二部分即可。</p>
<p>先考虑一个暴力做法：枚举后缀位置并且计算 $\text{lcp}$ 之和。利用 $\text{height}$ 数组可以将求解过程优化到 $O(n^2)$。</p>
<p>但是事实上，计算 $\text{lcp}$ 就是计算区间最小值，所以两两后缀 $\text{lcp}$ 之和其实就是 $\text{height}$ 数组所有区间最小值之和。</p>
<p>这个过程可以用单调栈维护，其时间复杂度为 $O(n)$。</p>
<h3 id="找相同字符"><a href="#找相同字符" class="headerlink" title="找相同字符"></a>找相同字符</h3><p>本质上是类似的，但是这个题要求两个串来自不同的字符串，考虑使用容斥，先将两个字符串拼起来求答案，再拆开减去两个字符串各自的答案。</p>
<p>答案的求解仍然是后缀 $\text{lcp}$ 之和。</p>
<p>代码：（差异）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> il inline</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500005</span></span><br><span class="line"><span class="function">il ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ll x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>) &#123;f=<span class="number">-1</span>;&#125; c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>);c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">	<span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line">ll n,m,x[N],y[N],cnt[N],sa[N],rk[N],height[N],be[N],ed[N],st[N],top;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="function">il <span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	m=<span class="number">127</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) x[i]=s[i],cnt[x[i]]++;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=m;i++) cnt[i]+=cnt[i<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--) sa[cnt[x[i]]--]=i;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> w=<span class="number">1</span>;w&lt;=n;w&lt;&lt;=<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="type">int</span> tot=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=n-w+<span class="number">1</span>;i&lt;=n;i++) y[++tot]=i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(sa[i]&gt;w) y[++tot]=sa[i]-w;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) cnt[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cnt[x[i]]++;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=m;i++) cnt[i]+=cnt[i<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--) sa[cnt[x[y[i]]]--]=y[i],y[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">swap</span>(x,y);tot=x[sa[<span class="number">1</span>]]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(y[sa[i]]==y[sa[i<span class="number">-1</span>]]&amp;&amp;y[sa[i]+w]==y[sa[i<span class="number">-1</span>]+w]) x[sa[i]]=tot;</span><br><span class="line">			<span class="keyword">else</span> x[sa[i]]=++tot;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(tot==n) <span class="keyword">break</span>;</span><br><span class="line">		m=tot;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) rk[sa[i]]=i;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,k=<span class="number">0</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(rk[i]==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(k) k--;</span><br><span class="line">		<span class="keyword">while</span>(s[i+k]==s[sa[rk[i]<span class="number">-1</span>]+k]) k++;</span><br><span class="line">		height[rk[i]]=k;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il ll <span class="title">solve2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) be[i]=<span class="number">0</span>,ed[i]=n+<span class="number">1</span>;</span><br><span class="line">	top=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">while</span>(top&gt;<span class="number">0</span>&amp;&amp;height[st[top]]&gt;=height[i]) &#123;</span><br><span class="line">			ed[st[top]]=i;</span><br><span class="line">			top--;</span><br><span class="line">		&#125;</span><br><span class="line">		st[++top]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	top=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--) &#123;</span><br><span class="line">		<span class="keyword">while</span>(top&gt;<span class="number">0</span>&amp;&amp;height[st[top]]&gt;height[i]) &#123;</span><br><span class="line">			be[st[top]]=i;</span><br><span class="line">			top--;</span><br><span class="line">		&#125;</span><br><span class="line">		st[++top]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	ll ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		ll l=i-be[i],r=ed[i]-i;</span><br><span class="line">		ans+=l*r*height[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">solve</span>();</span><br><span class="line">	ll ans=<span class="built_in">solve2</span>();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,n*(n<span class="number">-1</span>)*(n+<span class="number">1</span>)/<span class="number">2</span><span class="number">-2</span>*ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN-diy">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/26/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Qinshihuang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qinshihuang's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/26/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">字符串学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-26 21:21:43" itemprop="dateCreated datePublished" datetime="2024-04-26T21:21:43+08:00">2024-04-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-09 21:47:28" itemprop="dateModified" datetime="2024-05-09T21:47:28+08:00">2024-05-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><del>对不起了 zrz 字符串我忘光了</del></p>
<h1 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h1><p><del>万能的哈希，水过大量字符串题</del></p>
<h1 id="DFA"><a href="#DFA" class="headerlink" title="DFA"></a>DFA</h1><p>确定有限状态自动机，是一类可以识别文本内容的自动机。</p>
<p>它由五部分组成：</p>
<ol>
<li>$\Sigma$，字符集。</li>
<li>$Q$，所有的状态集合。</li>
<li>$st$，一个特殊的状态 $st\in Q$ 表示起始状态。</li>
<li>$F$，接受状态集合，$F\subseteq Q$。</li>
<li>状态转移函数 $\delta(q,c)$，从一个状态通过接收一个字符实现的转移。</li>
</ol>
<p>如何识别字符串？一个 DFA 收到字符串后从 $st$ 出发按照转移函数一步步转移，如果最后状态 $q\in F$ 则此字符串可被接受，否则不可。</p>
<p>DFA 是理解很多字符串算法的基础。</p>
<p><strong>例子</strong>：判定一个二进制串是否为偶数的 DFA：</p>
<p><img src="https://oi-wiki.org/string/images/automaton2.png" alt=""></p>
<p>在这个自动机中有两个状态 $Q=\{0,1\}$，字符集为 $\Sigma=\{\texttt{0},\texttt{1}\}$，初始状态 $st=0$，可接受状态集合 $F=\{0\}$，转移函数为</p>
<script type="math/tex; mode=display">
\delta(q,c)=\begin{cases}0&c=\texttt0\\1&c=\texttt1\end{cases}</script><p>显然如果二进制的最后一位是 $0$，那么最终状态会停在 $0$ 上，即可被接受。</p>
<h1 id="Trie-自动机"><a href="#Trie-自动机" class="headerlink" title="Trie 自动机"></a>Trie 自动机</h1><p><del>其实就是字典树啦</del></p>
<p>思想很好理解。每当插入一个新字符串，就从根节点向下转移，进一个字符 $c$ 就跳到 $\delta(q,c)$，如果没有这个节点就新建一个，最后在此次插入的终止节点上打上可被接受标记。</p>
<p>容易发现此结构形成了一棵树，而且其点数小于等于 $\sum|t_i|$，是一个经过空间压缩的存储字符串的结构。</p>
<h2 id="一些应用"><a href="#一些应用" class="headerlink" title="一些应用"></a>一些应用</h2><h3 id="查询一个字符串是否在给定模式串里出现过"><a href="#查询一个字符串是否在给定模式串里出现过" class="headerlink" title="查询一个字符串是否在给定模式串里出现过"></a>查询一个字符串是否在给定模式串里出现过</h3><p>很简单，将给定模式串建出 Trie，遇到新的字符串就看能否被此 Trie 接受即可。</p>
<p>其总时间复杂度为 $\sum|s_i|+\sum|t_i|$。</p>
<h3 id="查询一些正数中两两异或的最大值-P4551"><a href="#查询一些正数中两两异或的最大值-P4551" class="headerlink" title="查询一些正数中两两异或的最大值 P4551"></a>查询一些正数中两两异或的最大值 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4551">P4551</a></h3><p>经典的 01-Trie 应用。</p>
<p>考虑将每个整数从高位到低位写成二进制的形式（如果位数不同则补 $0$），容易贪心地发现两个数异或值想更大那么它们的高位要尽量不同。</p>
<p>将每一个二进制表示当成一个字符串来建出 Trie 来，此时直接把每一个数当成字符串在 Trie 上走即可，注意要走相反的字符而不是相同的字符。</p>
<p>总时间复杂度为 $O(n\log V)$。</p>
<h3 id="AC-自动机"><a href="#AC-自动机" class="headerlink" title="AC 自动机"></a>AC 自动机</h3><p>Trie 是 AC 自动机的结构基础。</p>
<h1 id="KMP-自动机"><a href="#KMP-自动机" class="headerlink" title="KMP 自动机"></a>KMP 自动机</h1><p>KMP 自动机解决单模式串匹配的问题。</p>
<p>考虑一些暴力或者乱搞方式：</p>
<ul>
<li>哈希，先将模式串求出哈希值，再对文本串求子串哈希，然后枚举每个长度与模式串相同的子串看哈希值是否相等。时间复杂度为 $O(n+m)$，但是由于有大量取模运算常数较大，且有错误概率，一般并不常用。</li>
<li>暴力，枚举每个起始点进行暴力匹配，跑得挺快，但是时间复杂度最大会被卡到 $O(nm)$，效率较低。<ul>
<li>随便一搞就可以搞出来，如 $s=\texttt{aaa…aaa}$，$t=\texttt{aaa…aaa}$，且 $|s|=2|t|$。</li>
</ul>
</li>
</ul>
<p>这样效率都不好。考察暴力做法，发现没有使用以前求出的信息，导致以前的计算被浪费了。这很不好。</p>
<h2 id="Fail"><a href="#Fail" class="headerlink" title="Fail"></a>Fail</h2><p>考虑一个新的匹配方式，利用以前匹配成功的信息减少运算次数。</p>
<p>首先定义一个字符串 $s$ 的 border：$s$ 的一个非本身的子串 $t$，使得 $t$ 既是 $s$ 的前缀又是 $s$ 的后缀。</p>
<p>不妨设 $s$ 的一个 border 是 $t$，border 的性质有这么几条：</p>
<ol>
<li>$|t|$ 比 $|s|$ 至少少 $1$。</li>
<li>$t$ 的 border 同样还是 $s$ 的 border。</li>
<li>一个字符串 $s$ 是重复字符串（即 $s$ 可以写成 $AAA\dots A$ 的形式）的充要条件是 $|t|\ge\dfrac{|s|}{2}$，且此时循环节的长度最大是 $|s|-|t|$。（这是为什么？）</li>
</ol>
<blockquote>
<p>性质 3 的证明：一张图结束疑问。</p>
</blockquote>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/r3p2sbge.png" alt=""></p>
<p>那得到 border 之后有什么用呢？</p>
<p>考虑我有两个字符串 $s_1,s_2$，如果当前我匹配到某一位时匹配失败了，我就不用再回到开头重新匹配，而是可以跳到当前成功匹配的最长 border 上继续匹配（因为两端是一样的）。</p>
<p>假设我已经求出了 $s_2$ 的每个前缀的 border，那么这个过程的时间复杂度是多少？</p>
<p>假设有一个指针 $p$ 指向当前 $s_2$ 匹配到的位置，考虑当 $s_1$ 向前匹配一位的时候，$p$ 最多加 $1$，而匹配失败时 $p$ 至少减 $1$，所以这个过程的时间复杂度是 $O(|s_1|+|s_2|)$，效率很好。</p>
<p>那么如何求出 border？</p>
<p>用相同的思路在 $s_2$ 上匹配自己一遍即可。时间复杂度为 $O(|s_2|)$。</p>
<p>这就是 KMP 自动机的核心思想，其中 border（或者更好听的名字：$\text{Fail}$ 指针）就是自动机的转移函数的一部分（另一部分当然是匹配成功的指针啦），而可接受状态只有一个就是 $s_2$ 的末端。</p>
<h2 id="例子-P4824"><a href="#例子-P4824" class="headerlink" title="例子 P4824"></a>例子 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4824">P4824</a></h2><p>首先不带删除的很简单对吧！直接 KMP 做即可。</p>
<p>考虑有删除怎么办，还是一样 KMP，在 KMP 的过程中将路过的字符以及其对应的 $\text{Fail}$ 压到栈中（方便还原状态），一旦遇到匹配成功的字符串就直接将这个成功的字符串从栈里面弹出去，并且根据栈顶还原匹配状态。</p>
<p>注意可能栈会被弹空了，这时候要还原状态为 $0$。</p>
<h2 id="例子-P3426"><a href="#例子-P3426" class="headerlink" title="例子 P3426"></a>例子 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3426">P3426</a></h2><p>线性的 KMP+dp 做法？没听说过，还是来个 $O(n\log n)$ 的暴力做法吧。</p>
<p>首先考虑一个印章合法的充要条件是什么？如果把印章字符串 $t$ 在欲印字符串 $s$ 上匹配，如果一次匹配的位置比上一次匹配的位置靠后超过 $|t|$ 个位置，那么就不可以。</p>
<p>其次，合法的印章一定是 $s$ 的 border。这个很显然吧。</p>
<p>然后一个暴力的做法呼之欲出：枚举每个 border 进行 KMP 匹配。</p>
<p>快速打完，交上去，诶，<strong>怎么有 80 分？</strong></p>
<p><del>（注意到我说的不是“怎么只有 80 分”）</del></p>
<p>这样不优在哪里呢？一个关键是<strong>没有利用以前的信息。</strong></p>
<p>考虑一个较短的 border，如果它能匹配一个较长的 border，那么较长的那个一定不优。</p>
<p>然后你从小到大去枚举 border，进行匹配即可。如果失败则替换答案。</p>
<p>可以证明这样的时间复杂度是 $O(n\log n)$。</p>
<h1 id="AC-自动机-1"><a href="#AC-自动机-1" class="headerlink" title="AC 自动机"></a>AC 自动机</h1><p>AC 自动机是上面两个玩意的综合。</p>
<p>考虑 KMP 的扩展，如果我有很多个模式串需要匹配，只使用 KMP 是不可行的（时间复杂度为 $O(n|s|+\sum|t_i|)$），需要一个更加高效的算法，而 AC 自动机就是这样一个东西。</p>
<p>AC 自动机的核心思想和 KMP 相同，即使用公共前缀后缀来进行信息利用从而节约时间。但不同的是：</p>
<ol>
<li>AC 自动机使用 Trie 树来存储大量的模式串。</li>
<li>AC 自动机里的 $\text{Fail}$ 指针不一定指向当前的字符串，也可能指向别的字符串的某一位置。</li>
</ol>
<p>所以这里构建 $\text{Fail}$ 就成了一个问题。</p>
<h2 id="构建-text-Fail-的基础方法"><a href="#构建-text-Fail-的基础方法" class="headerlink" title="构建 $\text{Fail}$ 的基础方法"></a>构建 $\text{Fail}$ 的基础方法</h2><p>对于一个字典树上的点 $u$，假设比 $u$ 深度小的点的 $\text{Fail}$ 指针全部求出。考虑 $u$ 父亲节点 $f$ 的指针，它指向的是 $f$ 最长公共前后缀。注意到 $f$ 加上一个字符后变成 $u$，其后缀也同样增加一个字符，那么如果 $\text{Fail}_f$ 对应的节点有一个同样的字符转移，那么对应的节点就是 $\text{Fail}_u$。如果没有？继续跳。</p>
<p>这样可以跳 $\text{Fail}$ 来进行处理。</p>
<p>但是这样会被轻松卡掉，因为每次跳都要耗费大量时间，不划算。</p>
<h2 id="Trie-图-AC-自动机完全体"><a href="#Trie-图-AC-自动机完全体" class="headerlink" title="Trie 图/AC 自动机完全体"></a>Trie 图/AC 自动机完全体</h2><p>考虑如何节省时间来跳 $\text{Fail}$，方式很神奇：让 Trie 从树变成图。</p>
<p>具体的，先前的 Trie 上每个节点只能从其父亲由一个字符转移而来。现在，我们让 Trie 上的每个节点的<strong>每个字符</strong>都有其对应的转移点。</p>
<p>那不存在对应字符转移的转移边意义是什么？<strong>是不断跳 $\text{Fail}$ 的最终结果</strong>。</p>
<p>比如说我有一个点 $u$，其并没有 $c$ 这个字符的转移。如果我必须转移 $c$ 这个字符，那么暴力的做法是不断地跳其 $\text{Fail}$ 指针直到找到有 $c$ 转移的那个节点 $v$。而现在我强制令 $\delta(u,c)=v$，这样不就能一步到位了吗？</p>
<p>那么如何构建 Trie 图呢？方法也很简单：广搜。</p>
<p>从根节点开始进行广搜，假设现在搜到了 $u$ 节点，接下来枚举字符集中的元素，假设枚举到 $c$。那么此时分两种情况：</p>
<ol>
<li>$\delta(u,c)$ 本来就存在，则记它为 $v$，那么就令 $\text{Fail}_v=\delta(\text{Fail}_u,c)$。这是为什么？为什么上面需要不断跳 $\text{Fail}$ 而这里不用？这就是 Trie 图的妙用，因为 Trie 图的一条边其实隐形地进行了多次跳 $\text{Fail}$ 操作，于是这里只需要跳一步即可。</li>
<li>$\delta(u,c)$ 不存在，那么补充这条边，令 $\delta(u,c)=\delta(\text{Fail}_u,c)$。原理是完全相同的。</li>
</ol>
<p>这样就将一棵 Trie 树变成了一个每个节点对每个字符都有一条转移边并且还有一个特殊的 $\text{Fail}$ 转移边的 AC 自动机，可以称之为 AC 自动机完全体了。</p>
<p>这个过程的时间复杂度显然为 $O(|\Sigma|n)$，$n$ 为 Trie 树上的点数并且小于等于 $\sum |s_i|$。</p>
<h2 id="在线的查询"><a href="#在线的查询" class="headerlink" title="在线的查询"></a>在线的查询</h2><p>就是把一个字符串丢进去并且按照 AC 自动机的转移状态进行转移并且根据打标记的节点进行统计答案即可。时间复杂度？目测是 $O(n)$ 的，但实际上是——</p>
<script type="math/tex; mode=display">
O(|s|\cdot |t|)</script><p>为什么？考虑在 AC 自动机的匹配过程中有一步需要在匹配到一个成功节点后不断跳 $\text{Fail}$ 以找到更多可被匹配的节点。这个过程的时间复杂度是 $O(|t|)$ 的，而且可以被以下的数据卡掉：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">aaa...abbb...bccc...cddd...d......</span><br><span class="line">a</span><br><span class="line">aa</span><br><span class="line">aaa</span><br><span class="line">...</span><br><span class="line">aa...ab</span><br><span class="line">aa...abb</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>这样子每个模式串都是一堆模式串的后缀，在匹配成功后会不断跳 $\text{Fail}$。时间复杂度是 $O(n^2)$ 的（至少是 $O(n\sqrt n)$ 吧，因为模式串的总和是给定的）。</p>
<h2 id="离线的查询"><a href="#离线的查询" class="headerlink" title="离线的查询"></a>离线的查询</h2><p>这里用到一个东西叫做<strong>拓扑排序优化</strong>。</p>
<p>就是说，我在匹配到合法字符串时不往下跳了，直接在这上面打标记，最后在 $\text{Fail}$ 树上用拓扑排序的方式将答案收起来。</p>
<h3 id="text-Fail-树是啥？"><a href="#text-Fail-树是啥？" class="headerlink" title="$\text{Fail}$ 树是啥？"></a>$\text{Fail}$ 树是啥？</h3><p>顾名思义，就是 $\text{Fail}$ 指针形成的树。</p>
<p>为啥是树？很简单，$\text{Fail}$ 指针的高度一定降低，不会成环，因此为树。</p>
<p>这东西有的时候有大用处，因为它描述了不同字符串之间的公共前后缀关系。</p>
<h2 id="例子-P3121"><a href="#例子-P3121" class="headerlink" title="例子 P3121"></a>例子 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3121">P3121</a></h2><p>P3426 的加强，就是把一个字符串换成了多个。</p>
<p>完全一样的做法，就是换在了 AC 自动机上。</p>
<h2 id="例子-P2414"><a href="#例子-P2414" class="headerlink" title="例子 P2414"></a>例子 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2414">P2414</a></h2><p>一道很好的 $\text{Fail}$ 树题。</p>
<p>首先按照题目给的方式把 Trie 树建出来并建立 AC 自动机的 $\text{Fail}$ 指针。接着将 $\text{Fail}$ 指针抽离出来成为 $\text{Fail}$ 树。</p>
<p>如果 $x$ 号字符串在 $y$ 号字符串里出现在失配树上意味着什么？考虑从根节点到 $y$ 结尾路径上的点集合 $A$，如果 $x$ 是 $y$ 的子串，那么一定有一个元素 $s\in A$，使得 $\text{Fail}_u$ 指向的节点的一个前缀为 $x$。</p>
<p>这个原理很简单，$\text{Fail}$ 指向的是后缀，再有个前缀就是子串。</p>
<p>一个字符串的一个前缀是 $x$，那么这个字符串对应的节点一定在 Trie 上是 $x$ 的子树节点。</p>
<p>考虑将询问离线下来，并在失配树上跑出 dfn 序，再 dfs 整棵 Trie 树（这俩树千万别搞混了），对其路径上的点打标记，最后每到一个有查询的节点就查询对应被查询节点的子树内标记之和。这个过程可用树状数组进行维护。</p>
<p>总时间复杂度 $O(n\log n)$。</p>
<h2 id="例子-P4052"><a href="#例子-P4052" class="headerlink" title="例子 P4052"></a>例子 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4052">P4052</a></h2><p>首先正难则反，考虑求出不能被阅读的文本串数量。</p>
<p>即求出满足字符串内无法匹配到一些模式串的长度一定的字符串数量。看到匹配想到将模式串建立 AC 自动机。然后考虑 dp。</p>
<blockquote>
<p>学长说 AC 自动机上的 dp 都十分套路。——某篇题解</p>
</blockquote>
<p>说得好！考虑设 $dp_{i,q}$ 表示枚举到字符串的第 $i$ 位、且 AC 自动机上匹配到 $q$ 的可行方案数量。那么转移很简单。</p>
<p>为了方便，这里的转移方程采用贡献形式而不是统计形式，因为一般来说 AC 自动机的转移边不好统计。</p>
<p>假设现在从 $q$ 出发向下贡献。显然可以先枚举下一位字符 $c$ 是什么，并求出向下的状态 $q^\prime=\delta(q,c)$。考虑如果 $q^\prime\in F$，那么这个转移是不合法的（一旦转移就会出现可匹配的串），不可进行直接跳过，否则就累加上答案，$dp_{i,q}\rightarrow dp_{i+1,\delta(q,c)}$。</p>
<p>初始化是长度为 $0$、状态为空字符串时答案是 $1$，因为空字符串无法匹配任何一个字符串。</p>
<p>时间复杂度为 $O(|\Sigma|\cdot m\sum|s_i|)$。</p>
<h2 id="例子-P3715"><a href="#例子-P3715" class="headerlink" title="例子 P3715"></a>例子 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3715">P3715</a></h2><p>还是一样的的 dp，设 $dp_{i,q}$，意义一样，转移方程除了需要多次跳转指针以外完全一样（因为换成了字符串）。时空复杂度是 $O(L\sum|s_i|)$。</p>
<p>但是你发现这玩意爆了。考虑优化。</p>
<p>设 $l=\max\{s_i\}$，考虑当固定 $i&gt;l$ 时是什么情况。显然在转移的时候枚举每个状态，将此状态的前面转移到这里。显然此状态是否为结尾状态是已知的。</p>
<p>因此这个转移方程可以写成状态转移到状态的一个方程。</p>
<p>这东西是个矩阵啊。</p>
<p>利用矩阵转移加速，时间复杂度为 $O\left(\left(\sum |s_i|\right)^3\log L\right)$，就能过了。</p>
<p>upd：实现细节好多啊！！！</p>
<blockquote>
<p>一个没有注意到但是致命的问题</p>
<p>在一个大结构体里经常会使用重载 <code>=</code> 来方便编写程序。但是这会出现问题，因为在结构体内的 <code>=</code> 运算<strong>一定不要有返回类型，一定要是 <code>void</code>！</strong></p>
<p>比如，以下这段代码就会 RE：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">matrix</span> &#123;</span><br><span class="line">   <span class="type">int</span> n,a[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line">   matrix <span class="keyword">operator</span> =(matrix A) &#123;</span><br><span class="line">       n=A.n;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">           a[i][j]=A.a[i][j];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而这段代码就没事：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">matrix</span> &#123;</span><br><span class="line">   <span class="type">int</span> n,a[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line">   <span class="type">void</span> <span class="keyword">operator</span> =(matrix A) &#123;		<span class="comment">//换成了 void</span></span><br><span class="line">       n=A.n;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">           a[i][j]=A.a[i][j];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="例子-P2603"><a href="#例子-P2603" class="headerlink" title="例子 P2603"></a>例子 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2603">P2603</a></h2><p>初看这道题：什么鬼东西这东西真的可做吗？</p>
<p>再看一下，似乎是类似于匹配的问题，但是这个匹配函数也太牛马了吧。</p>
<p>考虑判定两个点列是否可以匹配。</p>
<p>实际上，一个点列在平面内就是一条折线，其中相邻的每两条线段之间都有两个关键值：夹角 $\theta$ 与比值 $p$。显然如果两个长度相同为 $n$ 的点列，从第二条线段开始，第 $i$ 与第 $i-1$ 条线段的夹角与长度比值均相同，那么可以肯定，这两个点列可以匹配成功。</p>
<p>注意这里的角是有方向的。</p>
<p>接下来，发现 $(\theta,p)$ 就可以完成一个转移了。所以把这个鬼东西看成转移边，将欲匹配的点列建成 AC 自动机（一定记得要将原点列与翻转后的点列一起丢进去），并且将母串求进去进行匹配即可。</p>
<p>难点其实在于求线段比值与线段夹角。其实也不难，线段比值可以直接将其平方后记录比值的最简分数，夹角则可以用内外积进行比较。都可以转化成整数与整数进行比较，就没有精度丢失的风险了。</p>
<p>没写，周六再调试吧。<del>这东西肯定一写3个小时没了</del></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Qinshihuang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Qinshihuang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
